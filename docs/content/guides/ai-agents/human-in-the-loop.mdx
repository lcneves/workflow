---
title: Human-in-the-Loop
---

A common pre-requisite for running AI agents in production is the ability to wait for human input or external events before proceeding.

Workflow DevKit's [webhook](/docs/api-reference/workflow/create-webhook) and [hook](/docs/api-reference/workflow/define-hook) primitives enable "human-in-the-loop" patterns where workflows pause until a human takes action, allowing smooth resumption of workflows even after days of inactivity, and provides stability across code deployments.

If you need to react to external events programmatically, see the [hooks](/docs/foundations/hooks) documentation for more information. This part of the guide will focus on the human-in-the-loop pattern, which is a subset of the more general hook pattern.

## How It Works

<Steps>

<Step>
`createWebhook()` generates a unique URL that can be used to resume a workflow. This can be packaged as a tool for the Agent to call, or used directly in your backend code.
</Step>

<Step>
The workflow emits a data chunk containing the webhook URL, sending it to the consumer of the workflow, such as a chat UI.
</Step>

<Step>
The workflow pauses at `await webhook` - no compute resources are consumed while waiting for the human to take action.
</Step>

<Step>
The user of the workflow (e.g. a human in a chat UI) calls the webhook URL, optionally sending data back to the workflow.
</Step>

<Step>
The workflow receives any data sent with the webhook (e.g. approval status, comments) and resumes execution.
</Step>

</Steps>

## Creating a Booking Approval Tool

Add a tool that allows the agent to deliberately pause execution until a human approves or rejects a flight booking:

<Steps>

<Step>
### Implement the tool

Create a tool with an execute function that creates a webhook and emits a data chunk containing the webhook URL.

```typescript title="workflows/chat/steps/tools.ts" lineNumbers
import type { UIMessageChunk } from 'ai';
import { createWebhook, getWritable } from 'workflow'; // [!code highlight]
import { z } from 'zod';

async function executeBookingApproval(
  { flightNumber, passengerName, price }: { flightNumber: string; passengerName: string; price: number },
  { toolCallId }: { toolCallId: string }
) {
  // Note: No "use step" - webhooks are workflow-level primitives // [!code highlight]

  const webhook = createWebhook(); // [!code highlight]

  // Emit the approval URL to the UI
  await emitApprovalRequest(
    { url: webhook.url, flightNumber, passengerName, price },
    { toolCallId }
  );

  // Workflow pauses here until the webhook is called // [!code highlight]
  const request = await webhook; // [!code highlight]
  const { approved, comment } = await request.json(); // [!code highlight]

  if (!approved) {
    return `Booking rejected: ${comment || 'No reason provided'}`;
  }

  return `Booking approved for ${passengerName} on flight ${flightNumber}${comment ? ` - Note: ${comment}` : ''}`;
}

export const bookingApproval = {
  description: 'Request human approval before booking a flight',
  inputSchema: z.object({
    flightNumber: z.string().describe('Flight number to book'),
    passengerName: z.string().describe('Name of the passenger'),
    price: z.number().describe('Total price of the booking'),
  }),
  execute: executeBookingApproval,
};

// This is just a helper function to emit the approval request to the UI
async function emitApprovalRequest(
  { url, flightNumber, passengerName, price }: { url: string; flightNumber: string; passengerName: string; price: number },
  { toolCallId }: { toolCallId: string }
) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-booking-approval',
    data: { url, flightNumber, passengerName, price },
  });

  writer.releaseLock();
}
```

<Callout type="info">
The `createWebhook()` function must be called from within a workflow context, not from a step. This is why `executeBookingApproval` does not have `"use step"`, but the stream write operation requires a step context, which is why `emitApprovalRequest` is a separate function with `"use step"`.
</Callout>
</Step>

<Step>
### Create the Approval Component

The UI receives a data chunk with type `data-booking-approval`. Build a component that displays the approval request and handles the user's decision. Instead of giving the human UI to resolve this hook, this could also be sent to an external service, e.g. as a payment provider callback.

```typescript title="components/booking-approval.tsx" lineNumbers
'use client';

import { useState } from 'react';

interface BookingApprovalData {
  url: string;
  flightNumber: string;
  passengerName: string;
  price: number;
}

export function BookingApproval({ data }: { data: BookingApprovalData }) {
  const [comment, setComment] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isComplete, setIsComplete] = useState(false);

  const handleSubmit = async (approved: boolean) => {
    setIsSubmitting(true);
    try {
      await fetch(data.url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ approved, comment }),
      });
      setIsComplete(true);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isComplete) {
    return <div className="text-muted-foreground">Response submitted</div>;
  }

  return (
    <div className="border rounded-lg p-4 space-y-4">
      <div className="space-y-2">
        <p className="font-medium">Approve this booking?</p>
        <div className="text-sm text-muted-foreground">
          <div>Flight: {data.flightNumber}</div>
          <div>Passenger: {data.passengerName}</div>
          <div>Price: ${data.price}</div>
        </div>
      </div>

      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        placeholder="Add a comment (optional)..."
        className="w-full border rounded p-2 text-sm"
        rows={2}
      />

      <div className="flex gap-2">
        <button
          onClick={() => handleSubmit(true)}
          disabled={isSubmitting}
          className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Submitting...' : 'Approve'}
        </button>
        <button
          onClick={() => handleSubmit(false)}
          disabled={isSubmitting}
          className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50"
        >
          {isSubmitting ? 'Submitting...' : 'Reject'}
        </button>
      </div>
    </div>
  );
}
```

</Step>

<Step>
### Render in Your Chat

Handle the custom data chunk type in your message renderer:

```typescript title="app/page.tsx" lineNumbers
import { BookingApproval } from '@/components/booking-approval';

// Inside your message rendering:
{message.parts.map((part, i) => {
  if (part.type === 'text') {
    return <span key={i}>{part.text}</span>;
  }
  if (part.type === 'data-booking-approval') { // [!code highlight]
    return <BookingApproval key={i} data={part.data} />; // [!code highlight]
  } // [!code highlight]
  return null;
})}
```

</Step>

</Steps>

## Programmatic Hook Resumption

For scenarios where you need your backend code to resume a workflow (not just UI interactions), or when you want type-safe validation of approval data, use [`defineHook()`](/docs/api-reference/workflow/define-hook). This approach is useful for:

- Backend services that need to approve/reject based on business logic
- External systems that call your API to resume workflows
- Type-safe validation of approval data with Zod schemas

<Tabs items={['Hook Definition', 'Tool Implementation', 'API Route']}>

<Tab value="Hook Definition">

Define a typed hook with a Zod schema for validation:

```typescript title="workflows/chat/hooks/booking-approval.ts" lineNumbers
import { defineHook } from 'workflow';
import { z } from 'zod';

// Export the hook so it can be used in both the tool and API routes
export const bookingApprovalHook = defineHook({
  schema: z.object({
    approved: z.boolean(),
    approvedBy: z.string(),
    notes: z.string().optional(),
  }),
});
```

</Tab>

<Tab value="Tool Implementation">

Use the hook in your tool instead of `createWebhook()`:

```typescript title="workflows/chat/steps/tools.ts" lineNumbers
import { getWritable } from 'workflow';
import { z } from 'zod';
import type { UIMessageChunk } from 'ai';
import { bookingApprovalHook } from '../hooks/booking-approval';

async function emitBookingApproval(
  token: string,
  flightNumber: string,
  passengerName: string,
  price: number,
  toolCallId: string
) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-booking-approval',
    data: { token, flightNumber, passengerName, price },
  });

  writer.releaseLock();
}

async function executeBookingApproval(
  { flightNumber, passengerName, price }: { flightNumber: string; passengerName: string; price: number },
  { toolCallId }: { toolCallId: string }
) {
  const hook = bookingApprovalHook.create(); // [!code highlight]

  await emitBookingApproval(hook.token, flightNumber, passengerName, price, toolCallId);

  const approval = await hook; // [!code highlight]

  if (!approval.approved) {
    return `Booking rejected by ${approval.approvedBy}`;
  }

  return `Booking approved by ${approval.approvedBy}${approval.notes ? ` - Note: ${approval.notes}` : ''}`;
}

export const bookingApproval = {
  description: 'Request approval for a flight booking',
  inputSchema: z.object({
    flightNumber: z.string(),
    passengerName: z.string(),
    price: z.number(),
  }),
  execute: executeBookingApproval,
};
```

</Tab>

<Tab value="API Route">

Resume the hook from your backend API:

```typescript title="app/api/approve-booking/route.ts" lineNumbers
import { bookingApprovalHook } from '@/workflows/chat/hooks/booking-approval';

export async function POST(request: Request) {
  const { token, approved, approvedBy, notes } = await request.json();

  try {
    // Schema validation happens automatically // [!code highlight]
    await bookingApprovalHook.resume(token, { // [!code highlight]
      approved,
      approvedBy,
      notes,
    });

    return Response.json({ success: true });
  } catch (error) {
    return Response.json(
      { error: 'Invalid token or validation failed' },
      { status: 400 }
    );
  }
}
```

This API can be called by:

- Your UI components (passing the token from the data chunk)
- Backend services that need to programmatically approve/reject
- External systems via API integration
</Tab>

</Tabs>

## Related Documentation

- [Hooks & Webhooks](/docs/foundations/hooks) - Complete guide to hooks and webhooks
- [`createWebhook()` API Reference](/docs/api-reference/workflow/create-webhook) - Webhook configuration options
- [`defineHook()` API Reference](/docs/api-reference/workflow/define-hook) - Type-safe hook definitions

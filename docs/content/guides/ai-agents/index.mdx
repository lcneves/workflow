---
title: Building Durable AI Agents
---

AI agents are built on the primitive of LLM and tool-call loops, often with additional processes for data fetching, resource provisioning, or reacting to external events. Workflow DevKit makes your agents production-ready, by turning your agents into durable, resumable workflows, and managing your LLM calls, tool executions, and other async operations as retryable and observable steps.

This guide walks through converting a basic AI SDK agent into a durable agent using Workflow DevKit.

## Why Durable Agents?

Aside from the usual challenges of getting your long-running tasks to be production-ready, building mature AI agents typically requires solving several additional **challenges**:

- **Durability**: Persisting chat sessions and turning all LLM and tool calls into separate async jobs, with workers, queues, and state management, which repeatedly save and re-load state from a database.
- **Observability**: Using services to collect traces and metrics, separately storing your messages and user history, and then combining them to get a complete picture of your agent's behavior.
- **Resumability**: Separately from storing messages for replayability, most LLM calls are streams, and recovering from a call failure without re-doing the entire call requires piping and storing streams separately from your messages, usually in a separate service.
- **Human-in-the-loop**: Your client, API, and async job orchestration need to work together to create, track, route to, and display human approval requests, or similar webhook operations. If your stack is disjointed, this simple feature becomes a major orchestration challenge.

Workflow DevKit provides all of these capabilities out of the box. Your agent becomes a workflow, your tools become steps, and the framework handles interplay with your existing infrastructure.

## Getting Started

We start out with a basic Next.js application using the AI SDK's `Agent` class,
which is a simple wrapper around AI SDK's `streamText` function. It comes with a basic tool for reading web pages.

<Tabs items={['API Route', 'Tools', 'Client']}>

<Tab value="API Route">

```typescript title="app/api/chat/route.ts" lineNumbers
import { createUIMessageStreamResponse, Experimental_Agent as Agent, stepCountIs } from 'ai';
import { tools } from '@/ai/tools';

export async function POST(req: Request) {
  const { messages, modelId } = await req.json();

  const agent = new Agent({
    model: modelId,
    system: 'You are a helpful assistant.',
    tools,
    stopWhen: stepCountIs(20),
  });

  const stream = agent.stream({ messages });

  return createUIMessageStreamResponse({
    stream: stream.toUIMessageStream(),
  });
}
```

</Tab>

<Tab value="Tools">

```typescript title="ai/tools/index.ts" lineNumbers
import { tool } from 'ai';
import { z } from 'zod';

export const tools = {
  searchWeb: tool({
    description: 'Read a web page and return the content',
    inputSchema: z.object({ url: z.string() }),
    execute: async ({ url }: { url: string }) => {
      const response = await fetch(url);
      return response.text();
    },
  }),
};
```

</Tab>

<Tab value="Client">

```typescript title="app/chat.tsx" lineNumbers
'use client';

import { useChat } from '@ai-sdk/react';

export function Chat() {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: '/api/chat',
  });

  return (
    <div>
      {messages.map((m) => (
        <div key={m.id}>
          <strong>{m.role}:</strong>
          {m.parts.map((part, i) => {
            if (part.type === 'text') {
              return <span key={i}>{part.text}</span>;
            }
            if (part.type === 'tool-invocation') {
              return <div key={i}>Calling {part.toolInvocation.toolName}...</div>;
            }
            return null;
          })}
        </div>
      ))}
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={handleInputChange}
          placeholder="Type a message..."
        />
      </form>
    </div>
  );
}
```

</Tab>

</Tabs>

<Steps>

<Step>
### Install Dependencies

Add the Workflow DevKit packages to your project:

```bash
npm install workflow @workflow/ai
```

</Step>

<Step>
### Create a Workflow Function

Move the agent logic into a separate workflow function:

```typescript title="app/api/chat/workflow.ts" lineNumbers
import { DurableAgent } from '@workflow/ai/agent'; // [!code highlight]
import { getWritable } from 'workflow'; // [!code highlight]
import { stepCountIs } from 'ai';
import { tools } from '@/ai/tools';
import type { ModelMessage, UIMessageChunk } from 'ai';

export async function chatWorkflow({
  messages,
  modelId,
}: {
  messages: ModelMessage[];
  modelId: string;
}) {
  'use workflow'; // [!code highlight]

  const writable = getWritable<UIMessageChunk>(); // [!code highlight]

  const agent = new DurableAgent({ // [!code highlight]
    model: modelId,
    system: 'You are a helpful assistant.',
    tools: tools(),
  });

  await agent.stream({ // [!code highlight]
    messages,
    writable,
    stopWhen: stepCountIs(20),
  });
}
```

Key changes:

- Replace `Agent` with [`DurableAgent`](/docs/api-reference/workflow-ai/durable-agent) from `@workflow/ai/agent`
- Add the `"use workflow"` directive to mark this as a workflow function
- Use [`getWritable()`](/docs/api-reference/workflow/get-writable) to get a stream for agent output
- Pass the `writable` to `agent.stream()` instead of returning a stream directly
</Step>

<Step>
### Update the API Route

Replace the agent call with [`start()`](/docs/api-reference/workflow-api/start) to run the workflow:

```typescript title="app/api/chat/route.ts" lineNumbers
import { createUIMessageStreamResponse, convertToModelMessages } from 'ai';
import { start } from 'workflow/api'; // [!code highlight]
import { chatWorkflow } from './workflow'; // [!code highlight]

export async function POST(req: Request) {
  const { messages, modelId } = await req.json();
  const modelMessages = convertToModelMessages(messages);

  const run = await start(chatWorkflow, [{ messages: modelMessages, modelId }]); // [!code highlight]

  return createUIMessageStreamResponse({
    stream: run.readable, // [!code highlight]
  });
}
```

</Step>

<Step>
### Convert Tools to Steps

Mark tool execution functions with `"use step"` to make them durable. This enables automatic retries and observability:

```typescript title="ai/tools/search-web.ts" lineNumbers
import { tool } from 'ai';
import { z } from 'zod';

async function executeSearch({ query }: { query: string }) {
  'use step'; // [!code highlight]

  const response = await fetch(`https://api.search.com?q=${query}`);
  return response.json();
}

export const searchWeb = tool({
  description: 'Search the web for information',
  inputSchema: z.object({ query: z.string() }),
  execute: executeSearch,
});
```

With `"use step"`:

- The tool execution runs in a separate step with full Node.js access
- Failed tool calls are automatically retried (up to 3 times by default)
- Each tool execution appears as a discrete step in observability tools
- Results are persisted, so replays skip already-completed tools
</Step>

<Step>
### Stream Progress Updates from Tools

Tools can emit progress updates to the same stream the agent uses. This allows the UI to display tool status.

<Tabs items={['Tool', 'Client']}>

<Tab value="Tool">

```typescript title="ai/tools/search-web.ts" lineNumbers
import { tool } from 'ai';
import { getWritable } from 'workflow';
import { z } from 'zod';
import type { UIMessageChunk } from 'ai';

async function executeSearch(
  { url }: { url: string },
  { toolCallId }: { toolCallId: string }
) {
  'use step';

  const writable = getWritable<UIMessageChunk>(); // [!code highlight]
  const writer = writable.getWriter(); // [!code highlight]

  // Emit a progress update // [!code highlight]
  await writer.write({ // [!code highlight]
    id: toolCallId, // [!code highlight]
    type: 'data-search-web', // [!code highlight]
    data: { url, status: 'fetching' }, // [!code highlight]
  }); // [!code highlight]

  const response = await fetch(url);
  const content = await response.text();

  await writer.write({ // [!code highlight]
    id: toolCallId, // [!code highlight]
    type: 'data-search-web', // [!code highlight]
    data: { url, status: 'done' }, // [!code highlight]
  }); // [!code highlight]

  writer.releaseLock(); // [!code highlight]

  return content;
}

export const searchWeb = tool({
  description: 'Read a web page and return the content',
  inputSchema: z.object({ url: z.string() }),
  execute: executeSearch,
});
```

</Tab>

<Tab value="Client">

Handle the `data-search-web` chunks in your client to display progress. Data parts are stored in the message, so you can find the latest status directly:

```typescript title="app/chat.tsx" lineNumbers
'use client';

import { useChat } from '@ai-sdk/react';

export function Chat() {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: '/api/chat',
  });

  return (
    <div>
      {messages.map((m) => (
        <div key={m.id}>
          <strong>{m.role}:</strong>
          {m.parts.map((part, i) => {
            if (part.type === 'text') {
              return <span key={i}>{part.text}</span>;
            }
            if (part.type === 'tool-invocation') {
              // Find the latest data part for this tool call // [!code highlight]
              const dataPart = m.parts.findLast( // [!code highlight]
                (p) => p.type === 'data' && p.id === part.toolInvocation.toolCallId // [!code highlight]
              ); // [!code highlight]
              const status = dataPart?.type === 'data' ? dataPart.data : null; // [!code highlight]
              return (
                <div key={i}>
                  {status?.status === 'fetching' // [!code highlight]
                    ? `Fetching ${status.url}...` // [!code highlight]
                    : `Called ${part.toolInvocation.toolName}`} // [!code highlight]
                </div>
              );
            }
            return null;
          })}
        </div>
      ))}
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={handleInputChange}
          placeholder="Type a message..."
        />
      </form>
    </div>
  );
}
```

</Tab>

</Tabs>

</Step>

</Steps>

## Running the Workflow

Run your development server, then open the observability dashboard to see your workflow in action:

```bash
npx workflow web
```

This opens a local dashboard showing:

- All workflow runs and their status
- Individual step executions with timing
- Errors and retry attempts
- Stream data flowing through the workflow

## Next Steps

Now that you have a basic durable agent, explore these additional capabilities:

<Cards>
  <Card title="Resumable Streams" href="/guides/ai-agents/resumable-streams">
    Enable clients to reconnect to interrupted streams without losing data.
  </Card>
  <Card title="Sleep and Delays" href="/guides/ai-agents/sleep-and-delays">
    Add native sleep functionality for time-based workflows.
  </Card>
  <Card title="Human-in-the-Loop" href="/guides/ai-agents/human-in-the-loop">
    Implement approval workflows that wait for human input.
  </Card>
</Cards>

## Complete Example

Here is the complete code for the durable agent after all the steps above:

<Tabs items={['API Route', 'Workflow', 'Tools', 'Client']}>

<Tab value="API Route">

```typescript title="app/api/chat/route.ts" lineNumbers
import { createUIMessageStreamResponse, convertToModelMessages } from 'ai';
import { start } from 'workflow/api';
import { chatWorkflow } from './workflow';

export async function POST(req: Request) {
  const { messages, modelId } = await req.json();
  const modelMessages = convertToModelMessages(messages);

  const run = await start(chatWorkflow, [{ messages: modelMessages, modelId }]);

  return createUIMessageStreamResponse({
    stream: run.readable,
  });
}
```

</Tab>

<Tab value="Workflow">

```typescript title="app/api/chat/workflow.ts" lineNumbers
import { DurableAgent } from '@workflow/ai/agent';
import { getWritable } from 'workflow';
import { stepCountIs } from 'ai';
import { tools } from '@/ai/tools';
import type { ModelMessage, UIMessageChunk } from 'ai';

export async function chatWorkflow({
  messages,
  modelId,
}: {
  messages: ModelMessage[];
  modelId: string;
}) {
  'use workflow';

  const writable = getWritable<UIMessageChunk>();

  const agent = new DurableAgent({
    model: modelId,
    system: 'You are a helpful assistant.',
    tools,
  });

  await agent.stream({
    messages,
    writable,
    stopWhen: stepCountIs(20),
  });
}
```

</Tab>

<Tab value="Tools">

```typescript title="ai/tools/index.ts" lineNumbers
import { tool } from 'ai';
import { getWritable } from 'workflow';
import { z } from 'zod';
import type { UIMessageChunk } from 'ai';

async function executeSearch(
  { url }: { url: string },
  { toolCallId }: { toolCallId: string }
) {
  'use step';

  const writable = getWritable<UIMessageChunk>();
  const writer = writable.getWriter();

  await writer.write({
    id: toolCallId,
    type: 'data-search-web',
    data: { url, status: 'fetching' },
  });

  const response = await fetch(url);
  const content = await response.text();

  await writer.write({
    id: toolCallId,
    type: 'data-search-web',
    data: { url, status: 'done' },
  });

  writer.releaseLock();

  return content;
}

export const tools = {
  searchWeb: tool({
    description: 'Read a web page and return the content',
    inputSchema: z.object({ url: z.string() }),
    execute: executeSearch,
  }),
};
```

</Tab>

<Tab value="Client">

```typescript title="app/chat.tsx" lineNumbers
'use client';

import { useChat } from '@ai-sdk/react';

export function Chat() {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: '/api/chat',
  });

  return (
    <div>
      {messages.map((m) => (
        <div key={m.id}>
          <strong>{m.role}:</strong>
          {m.parts.map((part, i) => {
            if (part.type === 'text') {
              return <span key={i}>{part.text}</span>;
            }
            if (part.type === 'tool-invocation') {
              // Find the latest data part for this tool call
              const dataPart = m.parts.findLast(
                (p) => p.type === 'data' && p.id === part.toolInvocation.toolCallId
              );
              const status = dataPart?.type === 'data' ? dataPart.data : null;
              return (
                <div key={i}>
                  {status?.status === 'fetching'
                    ? `Fetching ${status.url}...`
                    : `Called ${part.toolInvocation.toolName}`}
                </div>
              );
            }
            return null;
          })}
        </div>
      ))}
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={handleInputChange}
          placeholder="Type a message..."
        />
      </form>
    </div>
  );
}
```

</Tab>

</Tabs>

## Related Documentation

- [`DurableAgent` API Reference](/docs/api-reference/workflow-ai/durable-agent) - Full API documentation
- [Workflows and Steps](/docs/foundations/workflows-and-steps) - Core concepts
- [Streaming](/docs/foundations/streaming) - In-depth streaming guide
- [Errors and Retries](/docs/foundations/errors-and-retries) - Error handling patterns

---
title: Monde PostgreSQL
---

Le monde PostgreSQL est une impl√©mentation de r√©f√©rence d'un [Monde](/docs/deploying/world) enti√®rement bas√©e sur PostgreSQL, incluant le traitement des jobs (en utilisant [pg-boss](https://github.com/timgit/pg-boss)) et le streaming (en utilisant NOTIFY et LISTEN de PostgreSQL).

Ce monde est con√ßu pour des processus de longue dur√©e : il peut recevoir et dispatcher des √©v√©nements depuis une base de donn√©es PostgreSQL, et n'est pas destin√© √† √™tre d√©ploy√© sur des plateformes serverless comme Vercel en raison de cette nature.

<Steps>

<Step>

## Installation

Installez le package `@workflow/world-postgres` :

```package-install
@workflow/world-postgres
```

</Step>

<Step>

## Ajouter des variables d'environnement

Ajoutez les variables d'environnement suivantes √† votre fichier `.env` requises pour les workflows :

```bash
WORKFLOW_TARGET_WORLD="@workflow/world-postgres"
WORKFLOW_POSTGRES_URL="postgres://postgres:password@db.yourdb.co:5432/postgres"
WORKFLOW_POSTGRES_JOB_PREFIX="workflow_"
WORKFLOW_POSTGRES_WORKER_CONCURRENCY=10
```

La configuration du monde est automatiquement lue depuis les variables d'environnement :

- `WORKFLOW_TARGET_WORLD` - Requis, sp√©cifie quelle impl√©mentation de monde utiliser
- `WORKFLOW_POSTGRES_URL` - Cha√Æne de connexion PostgreSQL (par d√©faut `postgres://world:world@localhost:5432/world`)
- `WORKFLOW_POSTGRES_JOB_PREFIX` - Pr√©fixe pour les noms des jobs de la file d'attente
- `WORKFLOW_POSTGRES_WORKER_CONCURRENCY` - Nombre de workers concurrents (par d√©faut `10` si non sp√©cifi√©)


</Step>

<Step>

## Configurer le sch√©ma de la base de donn√©es

Ex√©cutez le script d'installation pour cr√©er les tables de base de donn√©es requises :

```bash
pnpm exec workflow-postgres-setup
```

Ceci va cr√©er les tables suivantes dans votre base de donn√©es PostgreSQL :

- `workflow_runs` - Stocke l'√©tat d'ex√©cution des workflows
- `workflow_events` - Stocke les √©v√©nements des workflows
- `workflow_steps` - Stocke l'√©tat des √©tapes des workflows
- `workflow_hooks` - Stocke les hooks des workflows
- `workflow_stream_chunks` - Stocke les donn√©es de streaming

Vous devriez voir une sortie similaire :

```
üîß Setting up database schema...
üìç Connection: postgres://postgres:****@db.yourcloudprovider.co:5432/postgres
‚úÖ Database schema created successfully!
```

</Step>

<Step>

## Initialiser le Monde PostgreSQL

Le d√©marrage du Monde PostgreSQL variera selon les frameworks. L'id√©e principale est de d√©marrer le Monde PostgreSQL au d√©marrage du serveur.

Voici quelques exemples de ce √† quoi cela peut ressembler :

### Next.js

Cr√©ez un fichier `instrumentation.ts` √† la racine de votre projet pour initialiser et d√©marrer le monde :

```ts title="instrumentation.ts" lineNumbers
export async function register() {
  if (process.env.NEXT_RUNTIME !== "edge") {
    // Dynamic import to avoid edge runtime bundling issues
    console.log("Starting Postgres World...");
    const { getWorld } = await import("workflow/runtime");
    await getWorld().start?.();
    console.log("Postgres World started");
  }
}
```

<Callout>
  En savoir plus sur l'instrumentation [Next.js](https://nextjs.org/docs/app/guides/instrumentation).
</Callout>

### SvelteKit

Cr√©ez un fichier `src/hooks.server.ts` :

```ts title="src/hooks.server.ts" lineNumbers
import type { ServerInit } from "@sveltejs/kit";

export const init: ServerInit = async () => {
  if (process.env.WORKFLOW_TARGET_WORLD === "@workflow/world-postgres") {
    // Dynamic import to avoid edge runtime bundling issues
    const { getWorld } = await import("workflow/runtime");
    console.log("Starting Postgres World...");
    await getWorld().start?.();
    console.log("Postgres World started");
  }
};
```

<Callout>
  En savoir plus sur les [Hooks SvelteKit](https://svelte.dev/docs/kit/hooks).
</Callout>

### Applications bas√©es sur Nitro

Cr√©ez un plugin pour d√©marrer le Monde PostgreSQL. Celui-ci sera invoqu√© lorsque le serveur Nitro d√©marrera.

```ts title="plugins/start-pg-world.ts" lineNumbers
import { defineNitroPlugin } from "nitro/~internal/runtime/plugin";

export default defineNitroPlugin(async () => {
  if (process.env.WORKFLOW_TARGET_WORLD === "@workflow/world-postgres") {
    // Dynamic import to avoid edge runtime bundling issues
    console.log("Starting Postgres World...");
    const { getWorld } = await import("workflow/runtime");
    await getWorld().start?.();
    console.log("Postgres World started");
  }
});
```

Ajoutez le plugin √† votre fichier `nitro.config.ts`. Cela active le plugin :

```ts title="nitro.config.ts"
import { defineNitroConfig } from "nitropack";

export default defineNitroConfig({
  // ... your nitro config
  modules: ["workflow/nitro"],
  plugins: ["plugins/start-pg-world.ts"],
});
```

<Callout>
  En savoir plus sur les [Nitro Plugins](https://v3.nitro.build/docs/plugins)
</Callout>

</Step>

</Steps>

## Comment cela fonctionne

Le Monde PostgreSQL utilise PostgreSQL comme backend durable pour l'ex√©cution des workflows :

- **File d'attente de jobs**: Utilise [pg-boss](https://github.com/timgit/pg-boss) pour un traitement fiable des jobs
- **Streaming d'√©v√©nements**: Tire parti de NOTIFY/LISTEN de PostgreSQL pour la distribution d'√©v√©nements en temps r√©el
- **Persistance d'√©tat**: Tout l'√©tat des workflows est stock√© dans des tables PostgreSQL
- **Gestion des workers**: Prend en charge des workers concurrents configurables pour le traitement des jobs

Cette configuration garantit que vos workflows peuvent survivre aux red√©marrages et aux pannes de l'application, avec tout l'√©tat persistant de mani√®re fiable dans votre base de donn√©es PostgreSQL.
---
title: Entendendo Diretivas
---

import { File, Folder, Files } from "fumadocs-ui/components/files";

<Callout>
Este guia explora como diretivas JavaScript permitem o modelo de execução do Workflow DevKit. Para começar com workflows, veja os guias de [primeiros passos](/docs/getting-started) para o seu framework.
</Callout>

O Workflow Development Kit usa diretivas JavaScript (`"use workflow"` e `"use step"`) como base para seu modelo de execução durável. Diretivas fornecem a fronteira semântica em tempo de compilação necessária para que workflows possam suspender, retomar e manter comportamento determinístico durante replays.

Esta página explora como as diretivas possibilitam esse modelo de execução e os princípios de design que nos levaram até aqui.

Para entender como as diretivas funcionam, primeiro vamos entender o que são workflows e etapas no Workflow DevKit.

## Introdução a Workflows e Etapas

O Workflow DevKit possui dois tipos de funções:

**Funções de etapa** são operações com efeitos colaterais e com acesso total ao runtime Node.js. Pense nelas como chamadas RPC nomeadas — elas executam uma vez, seu resultado é persistido e podem ser [reexecutadas em caso de falha](/docs/foundations/errors-and-retries):

```typescript lineNumbers
async function fetchUserData(userId: string) {
  "use step";

  // Full Node.js access: database calls, API requests, file I/O
  const user = await db.query("SELECT * FROM users WHERE id = ?", [userId]);
  return user;
}
```

**Funções de workflow** são orquestradores determinísticos que coordenam etapas. Elas devem ser funções puras — durante o replay, os mesmos resultados de etapa sempre produzem a mesma saída. Isso é necessário porque workflows retomam executando seu código desde o início usando resultados de etapas em cache; lógica não determinística quebraria a retomada. Elas rodam em um ambiente isolado (sandbox) sem acesso direto ao Node.js:

```typescript lineNumbers
export async function onboardUser(userId: string) {
  "use workflow";

  const user = await fetchUserData(userId); // Calls step

  // Non-deterministic code would break replay behavior // [!code highlight]
  if (Math.random() > 0.5) { // [!code highlight]
    await sendWelcomeEmail(user); // [!code highlight]
  } // [!code highlight]

  return `Onboarded ${user.name}!`;
}
```

**A grande ideia:** Workflows retomam a partir de suspensão reexecutando seu código usando resultados de etapas em cache do registro de eventos. Quando uma etapa como `await fetchUserData(userId)` é chamada:

- **Se já executada:** Retorna imediatamente o resultado em cache do registro de eventos
- **Se ainda não executada:** Suspende o workflow, enfileira a etapa para execução em background e retoma depois com o resultado

Esse mecanismo de replay exige código determinístico. Se `Math.random()` não fosse inicializado de forma determinística, a primeira execução poderia retornar `0.7` (enviando o e-mail) mas o replay poderia retornar `0.3` (pulando-o), quebrando a retomada. O sandbox do Workflow DevKit fornece `Math.random()` e `Date` com seed para garantir comportamento consistente entre replays.

<Callout>
Para um mergulho mais profundo em workflows e etapas, veja [Workflows e Etapas](/docs/foundations/workflows-and-steps).
</Callout>

## O Desafio Principal

Esse modelo de execução habilita recursos de durabilidade poderosos — workflows podem suspender por dias, sobreviver reinicializações e retomar de qualquer ponto. No entanto, também exige uma fronteira semântica no código que indique ao **compilador, runtime e desenvolvedor** que a semântica de execução mudou.

O desafio: como marcar essa fronteira de modo que:

1. Habilite transformações e validações em tempo de compilação
2. Previna o uso acidental de APIs não determinísticas
3. Permita análise estática da estrutura do workflow
4. Seja natural para desenvolvedores JavaScript

Vamos ver onde diretivas já foram utilizadas antes e as alternativas que consideramos:

## Antecedentes sobre diretivas

Diretivas JavaScript têm precedentes para mudar a semântica de execução dentro de um escopo definido:

- `"use strict"` (introduzido no ECMAScript 5 em 2009, padronizado pelo TC39) altera regras da linguagem para tornar o runtime mais rápido, seguro e previsível.
- `"use client"` e `"use server"` (introduzidos por [React Server Components](https://react.dev/reference/rsc/server-components)) definem uma fronteira explícita de "onde" o código é executado — JavaScript no browser vs Node.js no servidor.
- `"use workflow"` (introduzido pelo Workflow DevKit) define tanto "onde" o código roda (em um ambiente sandbox determinístico) quanto "como" ele roda (semântica determinística, reexecutável e isolada).

Diretivas fornecem um contrato em tempo de build.

Quando o Workflow DevKit encontra `"use workflow"`, ele:

- Empacota o workflow e suas dependências em código que pode ser executado em um sandbox
- Restringe o acesso a APIs Node.js nesse sandbox
- Habilita funcionalidades futuras e otimizações possíveis apenas com uma ferramenta de build
  - Por exemplo, o código empacotado do workflow pode ser analisado estaticamente para gerar diagramas/visualizações UML do workflow

Além de ser importante para o compilador, `"use workflow"` sinaliza explicitamente ao desenvolvedor que você está entrando em um modo de execução diferente.

<Callout type="info">
A diretiva `"use workflow"` também é usada pelo Plugin de Language Server fornecido com o Workflow DevKit para oferecer IntelliSense à sua IDE. Verifique as instruções de [primeiros passos](/docs/getting-started) para o seu framework para detalhes sobre como configurar o Plugin de Language Server.
</Callout>

Mas não chegamos aqui imediatamente. Isso exigiu experimentação para chegar até este ponto:

## Alternativas que Exploramos

Antes de optar por diretivas, prototipamos diversas outras abordagens. Cada uma tinha limitações significativas que as tornavam inadequadas para uso em produção.

### API de "Suspense" apenas em runtime

Nosso primeiro proof of concept usou uma API baseada em wrappers sem etapa de build:

```typescript lineNumbers
export const myWorkflow = workflow(() => {
  const message = run(async () => step());
  return `${message}!`;
});
```

Essa implementação usava "promises lançadas" (semelhante ao primeiro React Suspense) para suspender a execução. Quando uma etapa precisava rodar, lançávamos uma promise, capturávamos na fronteira do workflow, executávamos a etapa e reexecutávamos o workflow com o resultado.

**Os problemas:**

**1. Todo efeito colateral precisava ser envolvido**

Qualquer operação que pudesse produzir resultados não determinísticos precisava ser envolvida em `run()`:

```typescript lineNumbers
export const myWorkflow = workflow(async () => {
  // These would be non-deterministic without wrapping
  const now = await run(() => Date.now()); // [!code highlight]
  const random = await run(() => Math.random()); // [!code highlight]
  const user = await run(() => fetchUser()); // [!code highlight]

  return { now, random, user };
});
```

Isso era verboso e fácil de esquecer. Além disso, se um desenvolvedor esquecesse de envolver algo aparentemente inocente como `Date.now()`, isso levava a comportamento instável em runtime.

Por exemplo:

```typescript lineNumbers
export const myWorkflow = workflow(async () => {
  // Nothing stops you from doing this:
  const now = Date.now(); // Non-deterministic, untracked! // [!code highlight]
  const user = await run(() => fetchUser());

  // This workflow would produce different results on replay // [!code highlight]
  return { now, user };
});
```

**2. Closures e mutação tornaram-se imprevisíveis**

Variáveis capturadas em closures se comportavam de forma inesperada quando etapas as mutavam:

```typescript lineNumbers
export const myWorkflow = workflow(async () => {
  let counter = 0;

  await run(() => {
    counter++; // This mutation happens during step execution // [!code highlight]
    return saveToDatabase(counter);
  });

  console.log(counter); // What is counter here? // [!code highlight]
  // During execution: 1 (mutation preserved) // [!code highlight]
  // During replay: 0 (mutation lost) // [!code highlight]
  // Inconsistent behavior! // [!code highlight]
});
```

A função do workflow seria reexecutada várias vezes, mas mutações dentro dos callbacks de `run()` não persistiriam entre replays. Isso tornava o raciocínio sobre estado quase impossível.

**3. Tratamento de erros falhava**

Como usamos promises lançadas para fluxo de controle, blocos `try/catch` tornaram-se pouco confiáveis:

```typescript lineNumbers
export const myWorkflow = workflow(async () => {
  try {
    const result = await run(() => step());
    return result;
  } catch (error) { // [!code highlight]
    // This could catch: // [!code highlight]
    // 1. A real error from the step // [!code highlight]
    // 2. The thrown promise used for suspension // [!code highlight]
    // 3. An error during replay // [!code highlight]
    // Hard to distinguish without special handling // [!code highlight]
    console.error(error);
  }
});
```

### API baseada em geradores

Exploramos usar geradores para pontos explícitos de suspensão, inspirados por bibliotecas como Effect.ts:

```typescript lineNumbers
export const myWorkflow = workflow(function*() {
  const message = yield* run(() => step());
  return `${message}!`;
});
```

<Callout type="info">
Somos grandes fãs do [Effect.ts](https://effect.website/) e do poder de APIs baseadas em geradores para gerenciamento de efeitos. No entanto, para orquestração de workflows especificamente, achamos a sintaxe pesada demais para desenvolvedores não familiarizados com geradores.
</Callout>

**Os problemas:**

**1. A sintaxe parecia mais um DSL do que JavaScript**

Geradores exigem um modelo mental customizado que difere significativamente dos padrões familiares de async/await. A sintaxe `yield*` e a delegação de geradores eram desconhecidas para muitos desenvolvedores:

```typescript lineNumbers
// Standard async/await (familiar)
const result = await fetchData();

// Generator-based (unfamiliar)
const result = yield* run(() => fetchData()); // [!code highlight]
```

Workflows complexos tornaram-se particularmente verbosos e difíceis de ler:

```typescript lineNumbers
export const myWorkflow = workflow(function*() {
  const user = yield* run(() => fetchUser());

  // Can't use Promise.all directly - need sequential calls or custom helpers // [!code highlight]
  const orders = yield* run(() => fetchOrders(user.id)); // [!code highlight]
  const payments = yield* run(() => fetchPayments(user.id)); // [!code highlight]

  // Or create a custom generator-aware parallel helper: // [!code highlight]
  const [orders2, payments2] = yield* all([ // [!code highlight]
    run(() => fetchOrders(user.id)), // [!code highlight]
    run(() => fetchPayments(user.id)) // [!code highlight]
  ]); // [!code highlight]

  return { user, orders, payments };
});
```

**2. Ainda sem sandboxing em tempo de compilação**

Como na abordagem apenas em runtime, geradores não podiam impedir código não determinístico:

```typescript lineNumbers
export const myWorkflow = workflow(function*() {
  const now = Date.now(); // Still possible, still problematic // [!code highlight]
  const user = yield* run(() => fetchUser());
  return { now, user };
});
```

A sintaxe de geradores tratava a suspensão mas não resolveu o problema fundamental de sandboxing.

### Convenções baseadas em sistema de arquivos

Exploramos usar convenções de sistema de arquivos para identificar workflows e etapas, similar a como frameworks modernos lidam com roteamento (Next.js, Hono, Nitro, SvelteKit):

<Files>
  <Folder name="workflows" defaultOpen>
    <File name="onboarding.ts" />
    <File name="checkout.ts" />
  </Folder>
  <Folder name="steps" defaultOpen>
    <File name="send-email.ts" />
    <File name="charge-payment.ts" />
  </Folder>
</Files>

Com essa abordagem, qualquer função no diretório `workflows/` seria transformada como um workflow, e qualquer função em `steps/` seria uma etapa. Não seriam necessárias diretivas, apenas localização de arquivos.

**Por que isso poderia funcionar:**

- Separação clara de responsabilidades
- Permite transformações do compilador baseadas no caminho do arquivo
- Padrão familiar para desenvolvedores acostumados com roteamento baseado em arquivos, por exemplo Next.js

**Por que nos afastamos:**

**1. Muito opinativo para ecossistemas diversos**

Diferentes frameworks e desenvolvedores têm opiniões fortes sobre estrutura de projeto. Forçar um layout específico de diretórios frequentemente causava conflitos com várias convenções, especialmente em bases de código existentes.

**2. Sem suporte para funções publicáveis e reutilizáveis**

Queremos que desenvolvedores possam publicar bibliotecas no npm que incluam diretivas de step e workflow. Idealmente, lógica isomórfica que possa ser usada com e sem Workflow DevKit. Convenções de sistema de arquivos tornavam isso impossível.

**3. Migração e reutilização de código ficaram difíceis**

Migrar código existente exigia mover arquivos e reestruturar projetos em vez de adicionar uma única linha.

A abordagem de diretiva resolveu todos esses problemas: funciona em qualquer estrutura de projeto, suporta reuso de código e migração, permite pacotes npm e permite que funções se adaptem ao seu contexto de execução.

### Decorators

Consideramos decorators, mas eles apresentaram desafios técnicos e ergonômicos significativos.

**Decorators não são padrão e são focados em classes**

Decorators ainda não são uma sintaxe padrão ([proposta do TC39](https://github.com/tc39/proposal-decorators)) e atualmente funcionam apenas com classes. Uma abordagem com class decorator poderia ser assim:

```typescript lineNumbers
import {workflow, step} from "workflow";

class MyWorkflow {
  @workflow() // [!code highlight]
  static async processOrder(orderId: string) { // [!code highlight]
    const order = await this.fetchOrder(orderId);
    const payment = await this.processPayment(order);
    return { orderId, payment };
  }

  @step() // [!code highlight]
  static async fetchOrder(orderId: string) { // [!code highlight]
    // ...
  }
}
```

Essa abordagem requer:

- Escrever boilerplate com classes e métodos estáticos
- Armazenar/mutar propriedades da classe não era óbvio (problemas de closure/mutação semelhantes à abordagem só runtime)
- Sintaxe baseada em classes que não parece "nativa do JavaScript" para desenvolvedores acostumados a padrões funcionais

Como o ecossistema JavaScript se moveu em direção a programação orientada por funções (exemplificada pela mudança do React de componentes de classe para funções e hooks), exigir que desenvolvedores usem classes pareceu um retrocesso e também não combinava com nossa própria preferência como autores do DevKit.

**O problema central: Apresenta workflows como código de runtime comum**

Embora decorators possam ser tratados em tempo de compilação com suporte de ferramentas de build, eles fazem com que funções de workflow pareçam código JavaScript regular e composável, quando na verdade são declarações em tempo de compilação que precisam de tratamento especial.

<Callout>
Veja a seção [Macro Wrapper](#macro-wrapper-approach) abaixo para uma análise mais profunda de por que essa abordagem falha, com exemplos concretos.
</Callout>

### Abordagem de Macro Wrapper

Também exploramos abordagens de macro em tempo de compilação — usando um compilador para transformar funções wrapper ou decorators em código baseado em diretivas:

```typescript lineNumbers
// Function wrapper approach
import { useWorkflow } from "workflow"

export const processOrder = useWorkflow(async (orderId: string) => { // [!code highlight]
  const order = await fetchOrder(orderId);
  return { orderId };
});

// Decorator approach (would work similarly)
class MyWorkflow {
  @workflow() // [!code highlight]
  static async processOrder(orderId: string) {
    const order = await fetchOrder(orderId);
    return { orderId };
  }

  // ...
}
```

O compilador poderia transformar ambos para serem equivalentes à abordagem baseada em diretivas do WDK:

```typescript lineNumbers
export const processOrder = async (orderId: string) => {
  "use workflow"; // [!code highlight]
  const order = await fetchOrder(orderId);
  return { orderId };
};
```

O benefício é que macros poderiam impor tipos e fornecer recursos de "Ir para definição" ou outras funcionalidades LSP por padrão.

No entanto, **o problema central permanece: Workflows não são valores de runtime**

A questão fundamental é que tanto wrappers quanto decorators fazem com que workflows pareçam ser **valores de primeira classe em runtime** quando na verdade são **declarações em tempo de compilação**. Esse desalinhamento entre sintaxe e semântica cria inúmeros modos de falha.

**Exemplos concretos de como isso falha:**

```typescript lineNumbers
// Someone writes a "helpful" utility
function withRetry(fn: Function) {
  return useWorkflow(async (...args) => { // Works with useWorkflow // [!code highlight]
    try {
      return await fn(...args);
    } catch (error) {
      return await fn(...args); // Retry once
    }
  });
}

// Note: the same utility would be written similarly for a decorator based syntax

// Usage looks innocent in both cases
export const processOrder = withRetry(async (orderId: string) => { // [!code highlight]
  // Is this deterministic? Can it call steps?
  // Nothing in this function indicates the developer is in the
  // deterministic sandboxed workflow
  // Also where is the retry happening? inside or outside the workflow?
  const order = await fetchOrder(orderId);
  return order;
});
```

O desenvolvedor que escreve `processOrder` não vê sinal visível de que está em um ambiente sandboxed e determinístico. Também é ambíguo se a lógica de retry executa dentro do workflow ou fora, e o comportamento real provavelmente não corresponde à intuição do desenvolvedor.

**Por que o compilador não consegue detectar isso:**

Para detectar que `processOrder` é na verdade um workflow, o compilador precisaria de análise de programa inteiro para rastrear que:

1. `withRetry` retorna o resultado de `useWorkflow`
2. Portanto `processOrder = withRetry(...)` é um workflow
3. A função passada para `withRetry` executará em um contexto sandboxed

Esse nível de análise cruzada entre funções é impraticável para ferramentas de build — exigiria analisar toda cadeia de chamadas na sua base de código e em todas as dependências. O compilador só pode detectar com segurança chamadas diretas a `useWorkflow`, não chamadas escondidas atrás de abstrações.

## Como Diretivas Resolvem Esses Problemas

Diretivas resolvem todas as questões que encontramos com as abordagens anteriores:

**1. Fronteira semântica em tempo de compilação**

A diretiva `"use workflow"` diz ao compilador para tratar esse código de forma diferente:

```typescript lineNumbers
export async function processOrder(orderId: string) {
  "use workflow"; // Compiler knows: transform this for sandbox execution // [!code highlight]

  const order = await fetchOrder(orderId); // Compiler knows: this is a step call // [!code highlight]
  return { orderId, order };
}
```

**2. Validação em tempo de build**

O compilador pode impor restrições antes do deploy:

```typescript lineNumbers
export async function badWorkflow() {
  "use workflow";

  const crypto = require("crypto"); // Build error: Node.js module in workflow // [!code highlight]
  return crypto.randomBytes(16);
}
```

De fato, o Workflow DevKit lançará um erro que aponta para esta página de erro: [Node.js module in workflow](/docs/errors/node-js-module-in-workflow)

**3. Sem ambiguidade de closure**

Etapas são transformadas em chamadas de função que se comunicam com o runtime:

```typescript lineNumbers
export async function processOrder(orderId: string) {
  "use workflow";

  let counter = 0;

  // This essentially becomes: await enqueueStep("updateCounter", [counter])
  // The step receives counter as a parameter, not a closure
  await updateCounter(counter); // [!code highlight]

  console.log(counter); // Always 0, consistently // [!code highlight]
}
```

Callbacks, no entanto, rodam dentro do sandbox do workflow e funcionam como esperado:

```typescript lineNumbers
export async function processOrders(orderIds: string[]) {
  "use workflow";

  let successCount = 0;

  // Callbacks run in the workflow context, not skipped on replay
  await Promise.all(orderIds.map(async (orderId) => {
    const order = await fetchOrder(orderId); // Step call
    if (order.status === "completed") {
      successCount++; // Mutation works correctly // [!code highlight]
    }
  }));

  console.log(successCount); // Consistent across replays
  return { total: orderIds.length, successful: successCount };
}
```

O callback executa no sandbox do workflow, então leituras de closure e mutações se comportam de forma consistente entre replays.

**4. Sintaxe natural**

Parece e se sente como JavaScript comum:

```typescript lineNumbers
export async function processOrder(orderId: string) {
  "use workflow";

  // Standard async/await patterns work naturally // [!code highlight]
  const [order, user] = await Promise.all([ // [!code highlight]
    fetchOrder(orderId), // [!code highlight]
    fetchUser(userId) // [!code highlight]
  ]); // [!code highlight]

  return { order, user };
}
```

**5. Sintaxe consistente para etapas**

A diretiva `"use step"` mantém a consistência. Embora etapas rodem com o runtime completo do Node.js e *pudessem* funcionar sem uma diretiva, elas precisam de uma forma de sinalizar ao runtime do workflow que são etapas.

Poderíamos ter usado um wrapper de função apenas para etapas:

```typescript lineNumbers
// Mixed approach (inconsistent)
export async function processOrder(orderId: string) {
  "use workflow"; // Directive for workflow // [!code highlight]

  const order = await step(async () => fetchOrder(orderId));
  return order;
}

const fetchOrder = useStep(() => { // Wrapper for step? // [!code highlight]
  // ...
})
```

Misturar sintaxes soou inconsistente.

Uma abordagem alternativa que consideramos foi tratar *todas* chamadas assíncronas como etapas por padrão:

```typescript lineNumbers
export async function processOrder(orderId: string) {
  "use workflow";

  // Every async call becomes a step automatically?
  const [order, user] = await Promise.all([ // [!code highlight]
    fetchOrder(orderId), // Step
    fetchUser(userId)    // Step
  ]);

  return { order, user };
}
```

Isso falha porque muitas operações assíncronas válidas dentro de workflows não são etapas:

```typescript lineNumbers
export async function processOrder(orderId: string) {
  "use workflow";

  // These are valid async calls that SHOULD NOT be steps:
  const results = await Promise.all([...]); // Language primitive // [!code highlight]
  const winner = await Promise.race([...]); // Language primitive // [!code highlight]

  // Helper function that formats data
  const formatted = await formatOrderData(order); // Pure JavaScript helper // [!code highlight]
}
```

Exigindo diretivas explícitas `"use step"`, desenvolvedores têm controle granular sobre o que se torna uma etapa durável e retryável versus o que roda inline no sandbox do workflow.

<Callout>
Para entender como diretivas são transformadas em tempo de compilação, veja [Como a Transformação de Código Funciona](/docs/how-it-works/code-transform).
</Callout>

## O que Diretivas Possibilitam

Porque `"use workflow"` define uma fronteira semântica em tempo de compilação, podemos oferecer:

<Cards>
  <Card title="Validação em tempo de build">
    O compilador detecta padrões inválidos antes do deploy: detecta imports proibidos, previne efeitos colaterais diretos e valida a estrutura do workflow.
  </Card>
  <Card title="Análise Estática">
    Analise o código do workflow sem executá-lo: gere diagramas UML ou DAG automaticamente, forneça observabilidade e visualização, e otimize caminhos de execução.
  </Card>
  <Card title="Execução Durável">
    Workflows podem suspender e retomar com segurança: persista o estado de execução entre etapas, retome de checkpoints após falhas ou deploys, e escale para zero sem perder progresso.
  </Card>
  <Card title="Otimizações Futuras">
    A fronteira semântica habilita melhorias planejadas: estado serializado menor para checkpoints mais rápidos, escalonamento mais inteligente baseado na estrutura do workflow, e suspensão/retomada mais eficientes.
  </Card>
</Cards>

## Diretivas como um Padrão JavaScript

Diretivas em JavaScript sempre foram contratos entre o desenvolvedor e o ambiente de execução. `"use strict"` tornou esse padrão familiar — é um literal de string que altera a interpretação do código.

Embora o JavaScript ainda não tenha suporte nativo para diretivas customizadas (como `#[attribute]` em Rust ou `#pragma` em C++), literais de string como diretivas são a ferramenta mais pragmática disponível hoje.

Como membros do TC39, nós na Vercel estamos trabalhando ativamente com o órgão de padronização e o ecossistema mais amplo para explorar especificações formais para sintaxes tipo pragma ou anotações de macro que possam expressar semânticas de execução.

## Considerações Finais

Diretivas não são sobre preferência de sintaxe, são sobre expressar fronteiras semânticas. `"use workflow"` informa ao compilador, desenvolvedor e runtime que esse código é determinístico, retomável e isolado.

Essa clareza permite que o Workflow Development Kit forneça execução durável com padrões JavaScript familiares, mantendo as garantias em tempo de compilação necessárias para orquestração de workflows confiável.
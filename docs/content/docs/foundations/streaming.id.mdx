---
title: Streaming
---

Workflows dapat mengirim data secara real-time ke klien tanpa menunggu seluruh workflow selesai. Ini memungkinkan pembaruan progres, konten yang dihasilkan AI, pesan log, dan data bertahap lainnya dikirim saat workflow berjalan.

## Memulai dengan `getWritable()`

Setiap run workflow memiliki stream writable default yang dapat ditulis oleh langkah menggunakan [`getWritable()`](/docs/api-reference/workflow/get-writable). Data yang ditulis ke stream ini langsung tersedia untuk klien yang mengkonsumsi output workflow.

```typescript title="workflows/simple-streaming.ts" lineNumbers
import { getWritable } from "workflow";

async function writeProgress(message: string) {
  "use step";

  // Steps can write to the run's default stream
  const writable = getWritable<string>(); // [!code highlight]
  const writer = writable.getWriter();
  await writer.write(message);
  writer.releaseLock();
}

export async function simpleStreamingWorkflow() {
  "use workflow";

  await writeProgress("Starting task...");
  await writeProgress("Processing data...");
  await writeProgress("Task complete!");
}
```

### Mengonsumsi Stream

Gunakan properti `readable` dari objek `Run` untuk mengonsumsi stream dari route API Anda:

```typescript title="app/api/stream/route.ts" lineNumbers
import { start } from "workflow/api";
import { simpleStreamingWorkflow } from "./workflows/simple";

export async function POST() {
  const run = await start(simpleStreamingWorkflow);

  // Return the readable stream to the client
  return new Response(run.readable, {
    headers: { "Content-Type": "text/plain" }
  });
}
```

Ketika klien melakukan permintaan ke endpoint ini, mereka akan menerima setiap pesan saat pesan tersebut ditulis, tanpa menunggu workflow selesai.

### Melanjutkan Stream dari Titik Tertentu

Gunakan `run.getReadable({ startIndex })` untuk melanjutkan stream dari posisi tertentu. Ini berguna untuk reconnect setelah timeout atau gangguan jaringan:

```typescript title="app/api/resume-stream/[runId]/route.ts" lineNumbers
import { getRun } from "workflow/api";

export async function GET(
  request: Request,
  { params }: { params: Promise<{ runId: string }> }
) {
  const { runId } = await params;
  const { searchParams } = new URL(request.url);

  // Client provides the last chunk index they received
  const startIndexParam = searchParams.get("startIndex"); // [!code highlight]
  const startIndex = startIndexParam ? parseInt(startIndexParam, 10) : undefined; // [!code highlight]

  const run = getRun(runId);
  const stream = run.getReadable({ startIndex }); // [!code highlight]

  return new Response(stream, {
    headers: { "Content-Type": "text/plain" }
  });
}
```

Ini memungkinkan klien untuk reconnect dan terus menerima data dari titik terakhir mereka menerima, alih-alih memulai ulang dari awal.

## Stream sebagai Tipe Data

[`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) dan [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) adalah tipe standar dari Web Streams API yang dibuat serializable oleh Workflow DevKit. Ini bukan tipe kustom - mereka mengikuti standar web - namun Workflow DevKit menambahkan kemampuan untuk meneruskan mereka antar fungsi sambil mempertahankan kemampuan streaming.

Berbeda dengan nilai biasa yang sepenuhnya diserialisasi ke event log, stream mempertahankan kemampuan streaming mereka saat diteruskan antar fungsi.

**Properti utama:**
- Referensi stream dapat diteruskan antara fungsi workflow dan step
- Data stream mengalir langsung tanpa disimpan di event log
- Stream mempertahankan statusnya melintasi titik penangguhan workflow

<Callout type="info">
**Bagaimana Stream Bertahan Melintasi Penangguhan Workflow**

Stream di Workflow DevKit didukung oleh penyimpanan persisten dan dapat dilanjutkan yang disediakan oleh implementasi "world". Inilah yang memungkinkan stream mempertahankan statusnya bahkan ketika workflow ditangguhkan dan dilanjutkan:

- **Vercel deployments**: Stream didukung oleh stream berbasis Redis yang berkinerja tinggi
- **Local development**: Potongan stream disimpan di filesystem
</Callout>

### Meneruskan Stream sebagai Argumen

Karena stream adalah tipe data yang dapat diserialisasi, Anda tidak perlu menggunakan [`getWritable()`](/docs/api-reference/workflow/get-writable). Anda bahkan bisa mengalirkan stream milik Anda sendiri melalui workflow, meneruskannya sebagai argumen dari luar ke dalam step.

Berikut contoh meneruskan request body stream melalui workflow ke step yang memprosesnya:

```typescript title="app/api/upload/route.ts" lineNumbers
import { start } from "workflow/api";
import { streamProcessingWorkflow } from "./workflows/streaming";

export async function POST(request: Request) {
  // Streams can be passed as workflow arguments
  const run = await start(streamProcessingWorkflow, [request.body]); // [!code highlight]
  await run.result();

  return Response.json({ status: "complete" });
}
```

```typescript title="workflows/streaming.ts" lineNumbers
export async function streamProcessingWorkflow(
  inputStream: ReadableStream<Uint8Array> // [!code highlight]
) {
  "use workflow";

  // Workflow passes stream to step for processing
  const result = await processInputStream(inputStream); // [!code highlight]
  return { length: result.length };
}

async function processInputStream(input: ReadableStream<Uint8Array>) {
  "use step";

  // Step reads from the stream
  const chunks: Uint8Array[] = [];

  for await (const chunk of input) {
    chunks.push(chunk);
  }

  return Buffer.concat(chunks).toString("utf8");
}
```

## Batasan Penting

<Callout type="info">
**Stream Tidak Dapat Digunakan Langsung di Konteks Workflow**

Anda tidak dapat membaca atau menulis ke stream secara langsung di dalam fungsi workflow. Semua operasi stream harus terjadi di fungsi step.
</Callout>

Fungsi workflow harus deterministik untuk mendukung replay. Karena stream melewati event log demi performa, membaca data stream di workflow akan merusak determinisme - setiap replay bisa melihat data yang berbeda. Dengan mengharuskan semua operasi stream terjadi di step, framework memastikan perilaku yang konsisten.

Untuk informasi lebih lanjut tentang determinisme dan replay, lihat [Workflows and Steps](/docs/foundations/workflows-and-steps).

```typescript title="workflows/bad-example.ts" lineNumbers
export async function badWorkflow() {
  "use workflow";

  const writable = getWritable<string>();

  // Cannot read/write streams in workflow context
  const writer = writable.getWriter(); // [!code highlight]
  await writer.write("data"); // [!code highlight]
}
```

```typescript title="workflows/good-example.ts" lineNumbers
export async function goodWorkflow() {
  "use workflow";

  // Delegate stream operations to steps
  await writeToStream("data");
}

async function writeToStream(data: string) {
  "use step";

  // Stream operations must happen in steps
  const writable = getWritable<string>();
  const writer = writable.getWriter();
  await writer.write(data);
  writer.releaseLock();
}
```

## Namespaced Streams

Gunakan `getWritable({ namespace: 'name' })` untuk membuat beberapa stream independen untuk berbagai tipe data. Ini berguna ketika Anda ingin memisahkan log, metrik, output data, atau saluran terpisah lainnya.

```typescript title="workflows/multi-stream.ts" lineNumbers
import { getWritable } from "workflow";

type LogEntry = { level: string; message: string };
type MetricEntry = { cpu: number; memory: number };

async function writeLogs() {
  "use step";

  const logs = getWritable<LogEntry>({ namespace: "logs" }); // [!code highlight]
  const writer = logs.getWriter();

  await writer.write({ level: "info", message: "Task started" });
  await writer.write({ level: "info", message: "Processing..." });

  writer.releaseLock();
}

async function writeMetrics() {
  "use step";

  const metrics = getWritable<MetricEntry>({ namespace: "metrics" }); // [!code highlight]
  const writer = metrics.getWriter();

  await writer.write({ cpu: 45, memory: 512 });
  await writer.write({ cpu: 52, memory: 520 });

  writer.releaseLock();
}

async function closeStreams() {
  "use step";

  await getWritable({ namespace: "logs" }).close();
  await getWritable({ namespace: "metrics" }).close();
}

export async function multiStreamWorkflow() {
  "use workflow";

  await writeLogs();
  await writeMetrics();
  await closeStreams();
}
```

### Mengonsumsi Namespaced Streams

Gunakan `run.getReadable({ namespace: 'name' })` untuk mengakses stream tertentu:

```typescript title="app/api/multi-stream/route.ts" lineNumbers
import { start } from "workflow/api";
import { multiStreamWorkflow } from "./workflows/multi";

type LogEntry = { level: string; message: string };
type MetricEntry = { cpu: number; memory: number };

export async function POST(request: Request) {
  const run = await start(multiStreamWorkflow);

  // Access specific named streams // [!code highlight]
  const logs = run.getReadable<LogEntry>({ namespace: "logs" }); // [!code highlight]
  const metrics = run.getReadable<MetricEntry>({ namespace: "metrics" }); // [!code highlight]

  // Return the logs stream to the client
  return new Response(logs, {
    headers: { "Content-Type": "application/json" }
  });
}
```

## Pola Umum

### Pembaruan Progres untuk Tugas yang Lama

Kirim pembaruan progres bertahap untuk menjaga pengguna tetap mendapat informasi selama workflow yang memakan waktu:

```typescript title="workflows/batch-processing.ts" lineNumbers
import { getWritable, sleep } from "workflow";

type ProgressUpdate = {
  item: string;
  progress: number;
  status: string;
};

async function processItem(
  item: string,
  current: number,
  total: number
) {
  "use step";

  const writable = getWritable<ProgressUpdate>(); // [!code highlight]
  const writer = writable.getWriter();

  // Simulate processing
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Send progress update // [!code highlight]
  await writer.write({ // [!code highlight]
    item, // [!code highlight]
    progress: Math.round((current / total) * 100), // [!code highlight]
    status: "processing" // [!code highlight]
  }); // [!code highlight]

  writer.releaseLock();
}

async function finalizeProgress() {
  "use step";

  await getWritable().close();
}

export async function batchProcessingWorkflow(items: string[]) {
  "use workflow";

  for (let i = 0; i < items.length; i++) {
    await processItem(items[i], i + 1, items.length);
    await sleep("1s");
  }

  await finalizeProgress();
}
```

### Streaming Respons AI dengan `DurableAgent`

Streaming konten yang dihasilkan AI menggunakan [`DurableAgent`](/docs/api-reference/workflow-ai/durable-agent) dari `@workflow/ai`. Tools juga dapat mengirim pembaruan progres ke stream yang sama menggunakan [data chunks](https://ai-sdk.dev/docs/ai-sdk-ui/streaming-data#streaming-custom-data) dengan tipe [`UIMessageChunk`](https://ai-sdk.dev/docs/ai-sdk-ui/stream-protocol) dari AI SDK:

```typescript title="workflows/ai-assistant.ts" lineNumbers
import { DurableAgent } from "@workflow/ai/agent";
import { getWritable } from "workflow";
import { z } from "zod";
import type { UIMessageChunk } from "ai";

async function searchFlights({ query }: { query: string }) {
  "use step";

  // Tools can emit progress updates to the stream
  const writable = getWritable<UIMessageChunk>(); // [!code highlight]
  const writer = writable.getWriter(); // [!code highlight]
  await writer.write({ // [!code highlight]
    type: "data-progress", // [!code highlight]
    data: { message: `Searching flights for ${query}...` }, // [!code highlight]
    transient: true, // [!code highlight]
  }); // [!code highlight]
  writer.releaseLock(); // [!code highlight]

  // ... search logic ...
  return { flights: [/* results */] };
}

export async function aiAssistantWorkflow(userMessage: string) {
  "use workflow";

  const agent = new DurableAgent({
    model: "anthropic/claude-haiku-4.5",
    system: "You are a helpful flight assistant.",
    tools: {
      searchFlights: {
        description: "Search for flights",
        inputSchema: z.object({ query: z.string() }),
        execute: searchFlights,
      },
    },
  });

  // LLM response will be streamed to the run's writable
  await agent.stream({
    messages: [{ role: "user", content: userMessage }],
    writable: getWritable<UIMessageChunk>(), // [!code highlight]
  });
}
```

```typescript title="app/api/ai-assistant/route.ts" lineNumbers
import { createUIMessageStreamResponse } from "ai";
import { start } from "workflow/api";
import { aiAssistantWorkflow } from "./workflows/ai";

export async function POST(request: Request) {
  const { message } = await request.json();

  const run = await start(aiAssistantWorkflow, [message]);

  return createUIMessageStreamResponse({
    stream: run.readable,
  });
}
```

<Callout type="info">
Untuk implementasi lengkap, lihat [flight booking example](https://github.com/vercel/workflow-examples/tree/main/flight-booking-app) yang menunjukkan streaming respons AI dengan pembaruan progres dari tool.
</Callout>

### Streaming Antar Step

Satu step menghasilkan stream dan step lain mengonsumsinya:

```typescript title="workflows/stream-pipeline.ts" lineNumbers
export async function streamPipelineWorkflow() {
  "use workflow";

  // Streams can be passed between steps
  const stream = await generateData(); // [!code highlight]
  const results = await consumeData(stream); // [!code highlight]

  return { count: results.length };
}

async function generateData(): Promise<ReadableStream<number>> {
  "use step";

  // Producer step creates a stream
  return new ReadableStream<number>({
    start(controller) {
      for (let i = 0; i < 10; i++) {
        controller.enqueue(i);
      }
      controller.close();
    }
  });
}

async function consumeData(readable: ReadableStream<number>) {
  "use step";

  // Consumer step reads from the stream
  const values: number[] = [];
  for await (const value of readable) {
    values.push(value);
  }
  return values;
}
```

### Memproses Berkas Besar Tanpa Beban Memori

Proses berkas besar dengan melakukan streaming potongan melalui langkah transformasi:

```typescript title="workflows/file-processing.ts" lineNumbers
export async function fileProcessingWorkflow(fileUrl: string) {
  "use workflow";

  // Chain streams through multiple processing steps
  const rawStream = await downloadFile(fileUrl); // [!code highlight]
  const processedStream = await transformData(rawStream); // [!code highlight]
  await uploadResult(processedStream); // [!code highlight]
}

async function downloadFile(url: string): Promise<ReadableStream<Uint8Array>> {
  "use step";
  const response = await fetch(url);
  return response.body!;
}

async function transformData(input: ReadableStream<Uint8Array>): Promise<ReadableStream<Uint8Array>> {
  "use step";

  // Transform stream chunks without loading entire file into memory
  return input.pipeThrough(new TransformStream<Uint8Array, Uint8Array>({
    transform(chunk, controller) {
      // Process each chunk individually
      controller.enqueue(chunk);
    }
  }));
}

async function uploadResult(stream: ReadableStream<Uint8Array>) {
  "use step";
  await fetch("https://storage.example.com/upload", {
    method: "POST",
    body: stream,
  });
}
```

## Praktik Terbaik

**Lepaskan lock dengan benar:**

```typescript lineNumbers
const writer = writable.getWriter();
try {
  await writer.write(data);
} finally {
  writer.releaseLock(); // Always release
}
```

<Callout type="info">
Lock stream yang diperoleh di sebuah step hanya berlaku dalam step tersebut, bukan di antara step lain. Ini memungkinkan beberapa writer menulis ke stream yang sama secara bersamaan.
</Callout>

<Callout type="info">
Jika lock tidak dilepaskan, proses step tidak dapat berhenti. Meskipun step mengembalikan nilai dan workflow berlanjut, proses yang mendasari akan tetap aktif sampai timeout terjadi.
</Callout>

**Tutup stream saat selesai:**

```typescript lineNumbers
async function finalizeStream() {
  "use step";

  await getWritable().close(); // Signal completion
}
```

Stream secara otomatis ditutup ketika run workflow selesai, namun menutupnya secara eksplisit memberi sinyal penyelesaian kepada konsumen lebih awal.

**Gunakan stream bertipe untuk keamanan tipe:**

```typescript lineNumbers
const writable = getWritable<MyDataType>();
const writer = writable.getWriter();
await writer.write({ /* typed data */ });
```

## Kegagalan Stream

Ketika sebuah step mengembalikan stream, step dianggap berhasil setelah stream dikembalikan, meskipun stream kemudian mengalami error. Workflow tidak akan otomatis mencoba ulang step tersebut. Konsumen stream harus menangani error dengan baik. Untuk lebih lanjut tentang perilaku retry, lihat [Errors and Retries](/docs/foundations/errors-and-retries).

```typescript title="workflows/stream-error-handling.ts" lineNumbers
import { FatalError } from "workflow";

async function produceStream(): Promise<ReadableStream<number>> {
  "use step";

  // Step succeeds once it returns the stream
  return new ReadableStream<number>({
    start(controller) {
      controller.enqueue(1);
      controller.enqueue(2);
      // Error occurs after step has completed // [!code highlight]
      controller.error(new Error("Stream failed")); // [!code highlight]
    }
  });
}

async function consumeStream(stream: ReadableStream<number>) {
  "use step";

  try { // [!code highlight]
    for await (const value of stream) {
      console.log(value);
    }
  } catch (error) { // [!code highlight]
    // Retrying won't help since the stream is already errored // [!code highlight]
    throw new FatalError("Stream failed"); // [!code highlight]
  } // [!code highlight]
}

export async function streamErrorWorkflow() {
  "use workflow";

  const stream = await produceStream(); // Step succeeds // [!code highlight]
  await consumeStream(stream); // Consumer handles errors // [!code highlight]
}
```

<Callout type="info">
Error pada stream tidak memicu retry otomatis untuk step producer. Rancang konsumen stream Anda agar menangani error dengan tepat. Karena stream sudah berada dalam keadaan errored, melakukan retry pada consumer tidak akan membantu - gunakan `FatalError` untuk menghentikan workflow secara langsung.
</Callout>

## Dokumentasi Terkait

- [`getWritable()` API Reference](/docs/api-reference/workflow/get-writable) - Dapatkan writable stream workflow
- [`sleep()` API Reference](/docs/api-reference/workflow/sleep) - Menjeda eksekusi workflow untuk jangka waktu
- [`start()` API Reference](/docs/api-reference/workflow-api/start) - Memulai workflow dan mengakses objek `Run`
- [`getRun()` API Reference](/docs/api-reference/workflow-api/get-run) - Mengambil run dan stream mereka nanti
- [DurableAgent](/docs/api-reference/workflow-ai/durable-agent) - Agen AI dengan dukungan streaming bawaan
- [Errors and Retries](/docs/foundations/errors-and-retries) - Memahami penanganan error dan perilaku retry
- [Serialization](/docs/foundations/serialization) - Memahami tipe data apa yang dapat diteruskan dalam workflow
- [Workflows and Steps](/docs/foundations/workflows-and-steps) - Konsep inti eksekusi workflow
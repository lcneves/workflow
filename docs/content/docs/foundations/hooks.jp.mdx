---
title: フックとウェブフック
---

フックは、ワークフローの実行を一時停止し、外部データで後で再開するための強力な仕組みを提供します。これにより、ワークフローは外部イベント、ユーザーの操作（「ヒューマン・イン・ザ・ループ」とも呼ばれる）、または HTTP リクエストを待機できるようになります。本ガイドでは、低レベルの Hook プリミティブから始めて、より高レベルの Webhook 抽象化までのコアコンセプトを説明します。

## フックの理解

本質的に、**フック**はワークフローを一時停止し、任意の[シリアライズ可能なデータ](/docs/foundations/serialization)で後から再開することを可能にする低レベルのプリミティブです。外部入力を待つワークフロー内のサスペンションポイントのようなものと考えてください。

フックを作成すると、外部システムがワークフローにデータを送り返すために使用できるユニークなトークンが生成されます。これにより、フックは次のようなシナリオに最適です:

- ユーザーまたは管理者からの承認を待つ
- 外部システムやサービスからデータを受け取る
- 時間をまたいで複数のイベントに反応するイベント駆動型ワークフローを実装する

### 最初のフックを作成する

まずは単純な例から始めましょう。以下はフックを作成して外部データを待つワークフローです。

```typescript lineNumbers
import { createHook } from "workflow";

export async function approvalWorkflow() {
  "use workflow";

  // Create a hook that expects an approval payload
  const hook = createHook<{ approved: boolean; comment: string }>();

  console.log("Waiting for approval...");
  console.log("Send approval to token:", hook.token);

  // Workflow pauses here until data is sent
  const result = await hook;

  if (result.approved) {
    console.log("Approved with comment:", result.comment);
    // Continue with approved workflow...
  } else {
    console.log("Rejected:", result.comment);
    // Handle rejection...
  }
}
```

ワークフローは `await hook` のところで一時停止し、外部コードがデータを送信して再開するまで待機します。

<Callout type="info">
[`createHook()`](/docs/api-reference/workflow/create-hook) の完全な API リファレンスを参照して、利用可能なすべてのオプションを確認してください。
</Callout>

### フックを再開する

待機中のワークフローにデータを送るには、API ルート、サーバーアクション、またはその他の外部コンテキストから [`resumeHook()`](/docs/api-reference/workflow-api/resume-hook) を使用します:

```typescript lineNumbers
import { resumeHook } from "workflow/api";

// In an API route or external handler
export async function POST(request: Request) {
  const { token, approved, comment } = await request.json();

  try {
    // Resume the workflow with the approval data
    const result = await resumeHook(token, { approved, comment });
    return Response.json({ success: true, runId: result.runId });
  } catch (error) {
    return Response.json({ error: "Invalid token" }, { status: 404 });
  }
}
```

主なポイント:
- フックはペイロードとして **任意の[シリアライズ可能なデータ](/docs/foundations/serialization)** を渡すことができます
- フックを再開するにはフックの `token` が必要です
- ワークフローは停止した箇所から実行を再開します

### 決定論的フックのためのカスタムトークン

デフォルトでは、フックはランダムなトークンを生成します。しかし、多くの場合、外部システムが再構築できる **カスタムトークン** を使用したいことがあります。これは、同じワークフローインスタンスが複数のイベントを処理すべき長時間実行のワークフローで特に有用です。

たとえば、各チャンネルごとにワークフローインスタンスを持つ Slack ボットを想像してください:

```typescript lineNumbers
import { createHook } from "workflow";

export async function slackChannelBot(channelId: string) {
  "use workflow";

  // Use channel ID in the token so Slack webhooks can find this workflow
  const hook = createHook<SlackMessage>({
    token: `slack_messages:${channelId}`
  });

  for await (const message of hook) {
    console.log(`${message.user}: ${message.text}`);

    if (message.text === "/stop") {
      break;
    }

    await processMessage(message);
  }
}

async function processMessage(message: SlackMessage) {
  "use step";
  // Process the Slack message
}
```

これで Slack の webhook ハンドラは適切なワークフローを決定論的に再開できます:

```typescript lineNumbers
import { resumeHook } from "workflow/api";

export async function POST(request: Request) {
  const slackEvent = await request.json();
  const channelId = slackEvent.channel;

  try {
    // Reconstruct the token using the channel ID
    await resumeHook(`slack_messages:${channelId}`, slackEvent);

    return new Response("OK");
  } catch (error) {
    return new Response("Hook not found", { status: 404 });
  }
}
```

### 複数イベントの受信

フックは再利用可能（_reusable_）です — `AsyncIterable` を実装しているため、`for await...of` を使って時間をかけて複数のイベントを受信できます:

```typescript lineNumbers
import { createHook } from "workflow";

export async function dataCollectionWorkflow() {
  "use workflow";

  const hook = createHook<{ value: number; done?: boolean }>();

  const values: number[] = [];

  // Keep receiving data until we get a "done" signal
  for await (const payload of hook) {
    values.push(payload.value);

    if (payload.done) {
      break;
    }
  }

  console.log("Collected values:", values);
  return values;
}
```

同じトークンで `resumeHook()` を呼び出すたびに、ループは別の値を受け取ります。

## ウェブフックの理解

フックは強力ですが、HTTP リクエストを手動で処理してワークフローにルーティングする必要があります。**ウェブフック**は、フックの上に構築された高レベルの抽象化でこれを解決します。ウェブフックは次を提供します:

1. HTTP の [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) オブジェクト全体を自動的にシリアライズする
2. 生成された webhook エンドポイントを指す自動的にアドレス可能な `url` プロパティを提供する
3. 呼び出し元に対して HTTP の [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) オブジェクトを返す処理を扱う

Workflow DevKit を使用している場合、ウェブフックは追加の設定なしに `/.well-known/workflow/v1/webhook/:token` に自動的に接続されます。

<Callout type="info">
[`createWebhook()`](/docs/api-reference/workflow/create-webhook) の完全な API リファレンスを参照して、利用可能なすべてのオプションを確認してください。
</Callout>

### 最初のウェブフックを作成する

HTTP リクエストを受け取るシンプルなウェブフックの例は次の通りです:

```typescript lineNumbers
import { createWebhook } from "workflow";

export async function webhookWorkflow() {
  "use workflow";

  const webhook = createWebhook();

  // The webhook is automatically available at this URL
  console.log("Send HTTP requests to:", webhook.url);
  // Example: https://your-app.com/.well-known/workflow/v1/webhook/lJHkuMdQ2FxSFTbUMU84k

  // Workflow pauses until an HTTP request is received
  const request = await webhook;

  console.log("Received request:", request.method, request.url);

  // Access the request body
  const data = await request.json();
  console.log("Data:", data);
}
```

ウェブフックはデフォルトで自動的に `202 Accepted` ステータスで応答します。外部システムは単に `webhook.url` に HTTP リクエストを送ることでワークフローを再開できます。

### カスタムレスポンスの送信

ウェブフックは、**静的レスポンス**と**動的レスポンス**の2つの方法でカスタム HTTP レスポンスを送信できます。

#### 静的レスポンス

`respondWith` オプションを使用して、すべてのリクエストに自動的に送信される静的レスポンスを指定します:

```typescript lineNumbers
import { createWebhook } from "workflow";

export async function webhookWithStaticResponse() {
  "use workflow";

  const webhook = createWebhook({
    respondWith: Response.json({
      success: true, message: "Webhook received"
    }),
  });

  const request = await webhook;

  // The response was already sent automatically
  // Continue processing the request asynchronously
  const data = await request.json();
  await processData(data);
}

async function processData(data: any) {
  "use step";
  // Long-running processing here
}
```

#### 動的レスポンス（手動モード）

リクエスト内容に基づく動的なレスポンスを行うには、`respondWith: "manual"` を設定し、リクエスト上で `respondWith()` メソッドを呼び出します:

```typescript lineNumbers
import { createWebhook, type RequestWithResponse } from "workflow";

async function sendCustomResponse(request: RequestWithResponse, message: string) {
  "use step";

  // Call respondWith() to send the response
  await request.respondWith(
    new Response(
      JSON.stringify({ message }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" }
      }
    )
  );
}

export async function webhookWithDynamicResponse() {
  "use workflow";

  // Set respondWith to "manual" to handle responses yourself
  const webhook = createWebhook({ respondWith: "manual" });

  const request = await webhook;
  const data = await request.json();

  // Decide what response to send based on the data
  if (data.type === "urgent") {
    await sendCustomResponse(request, "Processing urgently");
  } else {
    await sendCustomResponse(request, "Processing normally");
  }

  // Continue workflow...
}
```

<Callout type="warning">
`respondWith: "manual"` を使用する場合、`respondWith()` メソッドはシリアライズ要件のため **必ず** ステップ関数内から呼び出す必要があります。この要件は将来的に削除される可能性があります。
</Callout>

### 複数のウェブフクリクエストを処理する

フックと同様に、ウェブフックはイテレーションをサポートします:

```typescript lineNumbers
import { createWebhook, type RequestWithResponse } from "workflow";

async function respondToSlack(request: RequestWithResponse, text: string) {
  "use step";

  await request.respondWith(
    new Response(
      JSON.stringify({ response_type: "in_channel", text }),
      { headers: { "Content-Type": "application/json" } }
    )
  );
}

export async function slackCommandWorkflow(channelId: string) {
  "use workflow";

  const webhook = createWebhook({
    token: `slack_command:${channelId}`,
    respondWith: "manual"
  });

  console.log("Configure Slack command webhook:", webhook.url);

  for await (const request of webhook) {
    const formData = await request.formData();
    const command = formData.get("command");
    const text = formData.get("text");

    if (command === "/status") {
      await respondToSlack(request, "Checking status...");
      const status = await checkSystemStatus();
      await postToSlack(channelId, `Status: ${status}`);
    }

    if (text === "stop") {
      await respondToSlack(request, "Stopping workflow...");
      break;
    }
  }
}

async function checkSystemStatus() {
  "use step";
  return "All systems operational";
}

async function postToSlack(channelId: string, message: string) {
  "use step";
  // Post message to Slack
}
```

## フック vs ウェブフック: どちらを使うべきか

| 機能 | フック | ウェブフック |
|------|-------|-------------|
| **データ形式** | 任意のシリアライズ可能なデータ | HTTP の `Request` オブジェクト |
| **URL** | 自動 URL はなし | 自動的な `webhook.url` プロパティ |
| **レスポンス処理** | 該当なし | HTTP `Response` を送信できる（静的または動的） |
| **ユースケース** | カスタム統合、型安全なペイロード | HTTP ウェブフック、標準的な REST API |
| **再開方法** | [`resumeHook()`](/docs/api-reference/workflow-api/resume-hook) | HTTP による自動、または [`resumeWebhook()`](/docs/api-reference/workflow-api/resume-webhook) |

**次の場合はフックを使用してください:**
- ペイロード構造を完全に制御する必要がある場合
- カスタムイベントソースと統合している場合
- [`defineHook()`](/docs/api-reference/workflow/define-hook) による強力な TypeScript 型付けが必要な場合

**次の場合はウェブフックを使用してください:**
- 外部サービスから HTTP リクエストを受信する場合
- 呼び出し元に HTTP レスポンスを返す必要がある場合
- API ハンドラを記述せずに自動的な URL ルーティングが欲しい場合

## 高度なパターン

### `defineHook()` を使った型安全なフック

[`defineHook()`](/docs/api-reference/workflow/define-hook) ヘルパーは、フックの作成と再開の間で型安全性とランタイム検証を Standard Schema v1 (https://standardschema.dev) に基づいて提供します。Zod や Valibot のような準拠したバリデータを使用できます:

```typescript lineNumbers
import { defineHook } from "workflow";
import { z } from "zod";

// Define the hook with schema for type safety and runtime validation
const approvalHook = defineHook({ // [!code highlight]
  schema: z.object({ // [!code highlight]
    requestId: z.string(), // [!code highlight]
    approved: z.boolean(), // [!code highlight]
    approvedBy: z.string(), // [!code highlight]
    comment: z.string().transform((value) => value.trim()), // [!code highlight]
  }), // [!code highlight]
}); // [!code highlight]

// In your workflow
export async function documentApprovalWorkflow(documentId: string) {
  "use workflow";

  const hook = approvalHook.create({
    token: `approval:${documentId}`
  });

  // Payload is type-safe and validated
  const approval = await hook;

  console.log(`Document ${approval.requestId} ${approval.approved ? "approved" : "rejected"}`);
  console.log(`By: ${approval.approvedBy}, Comment: ${approval.comment}`);
}

// In your API route - both type-safe and runtime-validated!
export async function POST(request: Request) {
  const { documentId, ...approvalData } = await request.json();

  try {
    // The schema validates the payload before resuming the workflow
    await approvalHook.resume(`approval:${documentId}`, approvalData);
    return new Response("OK");
  } catch (error) {
    return Response.json({ error: "Invalid token or validation failed" }, { status: 400 });
  }
}
```

このパターンは、ワークフローと API コードが別ファイルにあるような大規模アプリケーションで特に有用で、コンパイル時の型安全性とランタイム検証の両方を提供します。

## ベストプラクティス

### トークン設計

カスタムトークンを使用する場合:

- **決定論的にする**: 外部システムが再構築できるデータ（チャンネル ID、ユーザー ID など）に基づかせる
- **名前空間を使用する**: トークンの衝突を避けるためにプレフィックスを付ける（例: `slack:${channelId}`, `github:${repoId}`）
- **ルーティング情報を含める**: 正しいワークフローインスタンスを識別できる十分な情報をトークンに含める

### ウェブフックでのレスポンス処理

- 簡単な確認応答には **静的レスポンス**（`respondWith: Response`）を使用する
- レスポンスがリクエスト処理に依存する場合は **手動モード**（`respondWith: "manual"`）を使用する
- `respondWith()` はステップ関数内から呼び出す必要があることを忘れないでください

### イベントの反復処理

フックとウェブフックはどちらもイテレーションをサポートしており、長時間のイベントループに最適です:

```typescript
const hook = createHook<Event>();

for await (const event of hook) {
  await processEvent(event);

  if (shouldStop(event)) {
    break;
  }
}
```

このパターンにより、単一のワークフローインスタンスが時間をかけて複数のイベントを処理し、イベント間で状態を維持できます。

## 関連ドキュメント

- [シリアライズ](/docs/foundations/serialization) - フックを通して渡せるデータの理解
- [`createHook()` API Reference](/docs/api-reference/workflow/create-hook)
- [`createWebhook()` API Reference](/docs/api-reference/workflow/create-webhook)
- [`defineHook()` API Reference](/docs/api-reference/workflow/define-hook)
- [`resumeHook()` API Reference](/docs/api-reference/workflow-api/resume-hook)
- [`resumeWebhook()` API Reference](/docs/api-reference/workflow-api/resume-webhook)
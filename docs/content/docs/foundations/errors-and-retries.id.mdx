---
title: Kesalahan & Pengulangan
---

Secara default, kesalahan yang dilemparkan di dalam langkah akan dicoba ulang. Selain itu, Workflow DevKit menyediakan dua jenis kesalahan baru yang dapat Anda gunakan untuk menyesuaikan pengulangan.

## Pengulangan Default

Secara default, langkah akan dicoba ulang hingga 3 kali pada kesalahan apa pun. Anda dapat menyesuaikan jumlah pengulangan dengan menambahkan properti `maxRetries` ke fungsi langkah.

```typescript lineNumbers
async function callApi(endpoint: string) {
  "use step";

  const response = await fetch(endpoint);

  if (response.status >= 500) {
    // Any uncaught error gets retried
    throw new Error("Uncaught exceptions get retried!"); // [!code highlight]
  }

  return response.json();
}

callApi.maxRetries = 5; // Set a custom number of retries
```

Langkah akan masuk antrean segera setelah kegagalan. Baca selanjutnya untuk melihat bagaimana ini dapat disesuaikan.

<Callout type="info">
  Ketika sebuah langkah yang dicoba ulang melakukan efek samping eksternal (pembayaran, email, penulisan ke API), pastikan panggilan tersebut bersifat <strong>idempoten</strong> untuk menghindari efek samping duplikat. Lihat <a href="/docs/foundations/idempotency">Idempotensi</a> untuk informasi lebih lanjut.
</Callout>

## Kesalahan yang Disengaja

Ketika langkah Anda perlu secara sengaja melempar kesalahan dan melewatkan pengulangan, cukup lempar [`FatalError`](/docs/api-reference/workflow/fatal-error).

```typescript lineNumbers
import { FatalError } from "workflow";

async function callApi(endpoint: string) {
  "use step";

  const response = await fetch(endpoint);

  if (response.status >= 500) {
    // Any uncaught error gets retried
    throw new Error("Uncaught exceptions get retried!");
  }

  if (response.status === 404) {
    throw new FatalError("Resource not found. Skipping retries."); // [!code highlight]
  }

  return response.json();
}
```

## Sesuaikan Perilaku Pengulangan

Saat Anda perlu menyesuaikan penundaan pada pengulangan, gunakan [`RetryableError`](/docs/api-reference/workflow/retryable-error) dan atur properti `retryAfter`.

```typescript lineNumbers
import { FatalError, RetryableError } from "workflow";

async function callApi(endpoint: string) {
  "use step";

  const response = await fetch(endpoint);

  if (response.status >= 500) {
    throw new Error("Uncaught exceptions get retried!");
  }

  if (response.status === 404) {
    throw new FatalError("Resource not found. Skipping retries.");
  }

  if (response.status === 429) {
    throw new RetryableError("Rate limited. Retrying...", { // [!code highlight]
      retryAfter: "1m", // Duration string // [!code highlight]
    }); // [!code highlight]
  }

  return response.json();
}
```

## Contoh Lanjutan

Contoh terakhir ini menggabungkan semua yang telah kita pelajari, bersama dengan [`getStepMetadata`](/docs/api-reference/workflow/get-step-metadata).

```typescript lineNumbers
import { FatalError, RetryableError, getStepMetadata } from "workflow";

async function callApi(endpoint: string) {
  "use step";

  const metadata = getStepMetadata();

  const response = await fetch(endpoint);

  if (response.status >= 500) {
    // Exponential backoffs
    throw new RetryableError("Backing off...", {
      retryAfter: (metadata.attempt ** 2) * 1000,  // [!code highlight]
    });
  }

  if (response.status === 404) {
    throw new FatalError("Resource not found. Skipping retries.");
  }

  if (response.status === 429) {
    throw new RetryableError("Rate limited. Retrying...", {
      retryAfter: new Date(Date.now() + 60000),  // Date instance // [!code highlight]
    });
  }

  return response.json();
}
callApi.maxRetries = 5;
```

## Membatalkan Langkah yang Gagal

Ketika sebuah workflow gagal di tengah jalan, hal itu dapat meninggalkan sistem dalam keadaan tidak konsisten. Pola umum untuk mengatasinya adalah "rollback": untuk setiap langkah yang berhasil, catat tindakan rollback yang sesuai yang dapat membatalkannya. Jika langkah berikutnya gagal, jalankan rollback dalam urutan terbalik untuk mengembalikan keadaan.

Pedoman utama:

- Buat rollback juga sebagai langkah, sehingga mereka tahan lama dan mendapat manfaat dari pengulangan.
- Pastikan rollback bersifat [idempoten](/docs/foundations/idempotency); mereka mungkin dijalankan lebih dari sekali.
- Hanya antrikan sebuah kompensasi setelah langkah maju (forward) terkait berhasil.

```typescript lineNumbers
// Forward steps
async function reserveInventory(orderId: string) {
  "use step";
  // ... call inventory service to reserve ...
}

async function chargePayment(orderId: string) {
  "use step";
  // ... charge the customer ...
}

// Rollback steps
async function releaseInventory(orderId: string) {
  "use step";
  // ... undo inventory reservation ...
}

async function refundPayment(orderId: string) {
  "use step";
  // ... refund the charge ...
}

export async function placeOrderSaga(orderId: string) {
  "use workflow";

  const rollbacks: Array<() => Promise<void>> = [];

  try {
    await reserveInventory(orderId);
    rollbacks.push(() => releaseInventory(orderId));

    await chargePayment(orderId);
    rollbacks.push(() => refundPayment(orderId));

    // ... more steps & rollbacks ...
  } catch (e) {
    for (const rollback of rollbacks.reverse()) {
      await rollback();
    }
    // Rethrow so the workflow records the failure after rollbacks
    throw e;
  }
}
```
---
title: Serialisasi
---

Semua argumen fungsi dan nilai yang dikembalikan yang dikirimkan antara fungsi workflow dan step harus dapat diserialisasi. Workflow DevKit menggunakan sistem serialisasi kustom yang dibangun di atas [devalue](https://github.com/sveltejs/devalue). Sistem ini mendukung tipe JSON standar, serta beberapa tipe Web API populer tambahan.

<Callout type="info">
Sistem serialisasi memastikan bahwa semua data dipertahankan dengan benar selama penangguhan dan pelanjutan workflow, memungkinkan eksekusi yang tahan lama.
</Callout>

## Tipe yang Didukung untuk Serialisasi

Tipe-tipe berikut dapat diserialisasi dan diteruskan melalui fungsi workflow:

**Tipe JSON Standar:**

- `string`
- `number`
- `boolean`
- `null`
- Arrays of serializable values
- Objects with string keys and serializable values

**Tipe Tambahan:**

- `undefined`
- `bigint`
- `ArrayBuffer`
- `BigInt64Array`, `BigUint64Array`
- `Date`
- `Float32Array`, `Float64Array`
- `Int8Array`, `Int16Array`, `Int32Array`
- `Map<Serializable, Serializable>`
- `RegExp`
- `Set<Serializable>`
- `URL`
- `URLSearchParams`
- `Uint8Array`, `Uint8ClampedArray`, `Uint16Array`, `Uint32Array`

**Perlu Diperhatikan:**

<Callout type="info">
Tipe-tipe ini memiliki penanganan khusus dan dijelaskan secara rinci pada bagian di bawah.
</Callout>

- `Headers`
- `Request`
- `Response`
- `ReadableStream<Serializable>`
- `WritableStream<Serializable>`

## Streaming

`ReadableStream` dan `WritableStream` didukung sebagai tipe yang dapat diserialisasi dengan penanganan khusus. Stream ini dapat diteruskan antara fungsi workflow dan step sambil mempertahankan kemampuan streaming mereka.

Untuk informasi lengkap tentang penggunaan stream dalam workflow, termasuk pola untuk streaming AI, pemrosesan file, dan pembaruan progres, lihat [Panduan Streaming](/docs/foundations/streaming).

## Request & Response

The Web API [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) and [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) APIs are supported by the serialization system,
and can be passed around between workflow and step functions similarly to other data types.

Sebagai kemudahan, kedua API ini diperlakukan sedikit berbeda ketika digunakan
di dalam fungsi workflow: memanggil metode instance `text()` / `json()` / `arrayBuffer()`
secara otomatis diperlakukan sebagai pemanggilan step. Ini memungkinkan Anda mengonsumsi
body secara langsung dalam konteks workflow sambil mempertahankan serialisasi dan caching yang tepat.

For example, consider how receiving a webhook request provides the entire `Request`
instance into the workflow context. You may consume the body of that request directly
in the workflow, which will be cached as a step result for future resumptions of the workflow:

```typescript title="workflows/webhook.ts" lineNumbers
import { createWebhook } from "workflow";

export async function handleWebhookWorkflow() {
  "use workflow";

  const webhook = createWebhook();
  const request = await webhook;

  // The body of the request will only be consumed once // [!code highlight]
  const body = await request.json(); // [!code highlight]

  // â€¦
}
```

### Menggunakan `fetch` dalam Workflow

Because `Request` and `Response` are serializable, Workflow DevKit provides a `fetch` function that can be used directly in workflow functions:

```typescript title="workflows/api-call.ts" lineNumbers
import { fetch } from "workflow"; // [!code highlight]

export async function apiWorkflow() {
  "use workflow";

  // fetch can be called directly in workflows // [!code highlight]
  const response = await fetch("https://api.example.com/data"); // [!code highlight]
  const data = await response.json();

  return data;
}
```

The implementation is straightforward - `fetch` from workflow is a step function that wraps the standard `fetch`:

```typescript title="Implementation" lineNumbers
export async function fetch(...args: Parameters<typeof globalThis.fetch>) {
  "use step";
  return globalThis.fetch(...args);
}
```

Ini memungkinkan Anda membuat permintaan HTTP langsung di fungsi workflow sambil mempertahankan perilaku replay deterministik melalui caching otomatis.

## Semantik Pengiriman Berdasarkan Nilai

**Parameter dikirim berdasarkan nilai, bukan berdasarkan referensi.** Step menerima salinan data yang telah dideserialisasi. Mutasi di dalam sebuah step tidak akan memengaruhi data asli di workflow.

**Salah:**

```typescript title="workflows/incorrect-mutation.ts" lineNumbers
export async function updateUserWorkflow(userId: string) {
  "use workflow";

  let user = { id: userId, name: "John", email: "john@example.com" };
  await updateUserStep(user);

  // user.email is still "john@example.com" // [!code highlight]
  console.log(user.email); // [!code highlight]
}

async function updateUserStep(user: { id: string; name: string; email: string }) {
  "use step";
  user.email = "newemail@example.com"; // Changes are lost // [!code highlight]
}
```

**Benar - kembalikan data yang dimodifikasi:**

```typescript title="workflows/correct-mutation.ts" lineNumbers
export async function updateUserWorkflow(userId: string) {
  "use workflow";

  let user = { id: userId, name: "John", email: "john@example.com" };
  user = await updateUserStep(user); // Reassign the return value // [!code highlight]

  console.log(user.email); // "newemail@example.com"
}

async function updateUserStep(user: { id: string; name: string; email: string }) {
  "use step";
  user.email = "newemail@example.com";
  return user; // [!code highlight]
}
```
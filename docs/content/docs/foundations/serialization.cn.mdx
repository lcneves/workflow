---
title: 序列化
---

所有在工作流和步骤函数之间传递的函数参数和返回值必须是可序列化的。Workflow DevKit 使用一个基于 [devalue](https://github.com/sveltejs/devalue) 构建的自定义序列化系统。该系统支持标准 JSON 类型，以及一些额外的常见 Web API 类型。

<Callout type="info">
序列化系统确保所有数据在工作流挂起和恢复期间正确持久化，从而实现持久执行。
</Callout>

## 支持的可序列化类型

以下类型可以被序列化并在工作流函数中传递：

**标准 JSON 类型：**

- `string`
- `number`
- `boolean`
- `null`
- 可序列化值的数组
- 具有字符串键和可序列化值的对象

**扩展类型：**

- `undefined`
- `bigint`
- `ArrayBuffer`
- `BigInt64Array`, `BigUint64Array`
- `Date`
- `Float32Array`, `Float64Array`
- `Int8Array`, `Int16Array`, `Int32Array`
- `Map<Serializable, Serializable>`
- `RegExp`
- `Set<Serializable>`
- `URL`
- `URLSearchParams`
- `Uint8Array`, `Uint8ClampedArray`, `Uint16Array`, `Uint32Array`

**注意：**

<Callout type="info">
这些类型具有特殊处理，下面各节中将详细说明。
</Callout>

- `Headers`
- `Request`
- `Response`
- `ReadableStream<Serializable>`
- `WritableStream<Serializable>`

## 流式处理

`ReadableStream` 和 `WritableStream` 作为可序列化类型被支持，并有特殊处理。这些流可以在工作流和步骤函数之间传递，同时保持其流式能力。

有关在工作流中使用流的完整信息，包括用于 AI 流、文件处理和进度更新的模式，请参阅 [流式指南](/docs/foundations/streaming)。

## 请求与响应

Web API 的 [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) 和 [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) API 受序列化系统支持，可以像其他数据类型一样在工作流和步骤函数之间传递。

为了方便，在工作流函数中使用这两个 API 时会有略微不同的处理：调用 `text()` / `json()` / `arrayBuffer()` 实例方法会自动被视为一次步骤函数调用。这允许你在工作流上下文中直接消费主体，同时保持正确的序列化和缓存。

例如，考虑接收 webhook 请求时如何将整个 `Request` 实例提供到工作流上下文中。你可以直接在工作流中消费该请求的主体，它将作为步骤结果被缓存，以便在工作流将来恢复时使用：

```typescript title="workflows/webhook.ts" lineNumbers
import { createWebhook } from "workflow";

export async function handleWebhookWorkflow() {
  "use workflow";

  const webhook = createWebhook();
  const request = await webhook;

  // The body of the request will only be consumed once // [!code highlight]
  const body = await request.json(); // [!code highlight]

  // …
}
```

### 在工作流中使用 `fetch`

由于 `Request` 和 `Response` 是可序列化的，Workflow DevKit 提供了一个可直接在工作流函数中使用的 `fetch` 函数：

```typescript title="workflows/api-call.ts" lineNumbers
import { fetch } from "workflow"; // [!code highlight]

export async function apiWorkflow() {
  "use workflow";

  // fetch can be called directly in workflows // [!code highlight]
  const response = await fetch("https://api.example.com/data"); // [!code highlight]
  const data = await response.json();

  return data;
}
```

实现很简单——来自工作流的 `fetch` 是一个将标准 `fetch` 包装起来的步骤函数：

```typescript title="Implementation" lineNumbers
export async function fetch(...args: Parameters<typeof globalThis.fetch>) {
  "use step";
  return globalThis.fetch(...args);
}
```

这允许你在工作流函数中直接发出 HTTP 请求，同时通过自动缓存保持确定性的重放行为。

## 按值传递语义

**参数按值传递，而不是按引用。** 步骤会接收数据的反序列化副本。在步骤内部的修改不会影响工作流中的原始数据。

**错误示例：**

```typescript title="workflows/incorrect-mutation.ts" lineNumbers
export async function updateUserWorkflow(userId: string) {
  "use workflow";

  let user = { id: userId, name: "John", email: "john@example.com" };
  await updateUserStep(user);

  // user.email is still "john@example.com" // [!code highlight]
  console.log(user.email); // [!code highlight]
}

async function updateUserStep(user: { id: string; name: string; email: string }) {
  "use step";
  user.email = "newemail@example.com"; // Changes are lost // [!code highlight]
}
```

**正确示例 - 返回已修改的数据：**

```typescript title="workflows/correct-mutation.ts" lineNumbers
export async function updateUserWorkflow(userId: string) {
  "use workflow";

  let user = { id: userId, name: "John", email: "john@example.com" };
  user = await updateUserStep(user); // Reassign the return value // [!code highlight]

  console.log(user.email); // "newemail@example.com"
}

async function updateUserStep(user: { id: string; name: string; email: string }) {
  "use step";
  user.email = "newemail@example.com";
  return user; // [!code highlight]
}
```
---
title: Errores y reintentos
---

Por defecto, los errores lanzados dentro de los pasos se reintentan. Además, Workflow DevKit proporciona dos nuevos tipos de errores que puedes usar para personalizar los reintentos.

## Reintentos predeterminados

Por defecto, los pasos se reintentan hasta 3 veces ante errores arbitrarios. Puedes personalizar el número de reintentos añadiendo una propiedad `maxRetries` a la función del paso.

```typescript lineNumbers
async function callApi(endpoint: string) {
  "use step";

  const response = await fetch(endpoint);

  if (response.status >= 500) {
    // Any uncaught error gets retried
    throw new Error("Uncaught exceptions get retried!"); // [!code highlight]
  }

  return response.json();
}

callApi.maxRetries = 5; // Set a custom number of retries
```

Los pasos se encolan inmediatamente después de una falla. Sigue leyendo para ver cómo se puede personalizar esto.

<Callout type="info">
  Cuando un paso reintentado realiza efectos secundarios externos (pagos, correos electrónicos, escrituras en API), asegúrate de que esas llamadas sean <strong>idempotentes</strong> para evitar efectos secundarios duplicados. Consulta <a href="/docs/foundations/idempotency">Idempotencia</a> para más información.
</Callout>

## Errores intencionados

Cuando tu paso necesita lanzar intencionadamente un error y omitir el reintento, simplemente lanza un [`FatalError`](/docs/api-reference/workflow/fatal-error).

```typescript lineNumbers
import { FatalError } from "workflow";

async function callApi(endpoint: string) {
  "use step";

  const response = await fetch(endpoint);

  if (response.status >= 500) {
    // Any uncaught error gets retried
    throw new Error("Uncaught exceptions get retried!");
  }

  if (response.status === 404) {
    throw new FatalError("Resource not found. Skipping retries."); // [!code highlight]
  }

  return response.json();
}
```

## Personalizar el comportamiento de reintento

Cuando necesites personalizar el retraso en un reintento, usa [`RetryableError`](/docs/api-reference/workflow/retryable-error) y establece la propiedad `retryAfter`.

```typescript lineNumbers
import { FatalError, RetryableError } from "workflow";

async function callApi(endpoint: string) {
  "use step";

  const response = await fetch(endpoint);

  if (response.status >= 500) {
    throw new Error("Uncaught exceptions get retried!");
  }

  if (response.status === 404) {
    throw new FatalError("Resource not found. Skipping retries.");
  }

  if (response.status === 429) {
    throw new RetryableError("Rate limited. Retrying...", { // [!code highlight]
      retryAfter: "1m", // Duration string // [!code highlight]
    }); // [!code highlight]
  }

  return response.json();
}
```

## Ejemplo avanzado

Este ejemplo final combina todo lo aprendido, junto con [`getStepMetadata`](/docs/api-reference/workflow/get-step-metadata).

```typescript lineNumbers
import { FatalError, RetryableError, getStepMetadata } from "workflow";

async function callApi(endpoint: string) {
  "use step";

  const metadata = getStepMetadata();

  const response = await fetch(endpoint);

  if (response.status >= 500) {
    // Exponential backoffs
    throw new RetryableError("Backing off...", {
      retryAfter: (metadata.attempt ** 2) * 1000,  // [!code highlight]
    });
  }

  if (response.status === 404) {
    throw new FatalError("Resource not found. Skipping retries.");
  }

  if (response.status === 429) {
    throw new RetryableError("Rate limited. Retrying...", {
      retryAfter: new Date(Date.now() + 60000),  // Date instance // [!code highlight]
    });
  }

  return response.json();
}
callApi.maxRetries = 5;
```

## Revertir pasos fallidos

Cuando un flujo de trabajo falla a mitad de ejecución, puede dejar el sistema en un estado inconsistente.
Un patrón común para abordar esto son las "reversiones" (rollbacks): por cada paso exitoso, registra una acción de reversión correspondiente que pueda deshacerlo.
Si un paso posterior falla, ejecuta las reversiones en orden inverso para deshacer los cambios.

Directrices clave:

- Haz que las reversiones también sean pasos, de modo que sean duraderas y se beneficien de los reintentos.
- Asegúrate de que las reversiones sean [idempotentes](/docs/foundations/idempotency); pueden ejecutarse más de una vez.
- Solo encola una compensación después de que su paso hacia adelante haya tenido éxito.

```typescript lineNumbers
// Forward steps
async function reserveInventory(orderId: string) {
  "use step";
  // ... call inventory service to reserve ...
}

async function chargePayment(orderId: string) {
  "use step";
  // ... charge the customer ...
}

// Rollback steps
async function releaseInventory(orderId: string) {
  "use step";
  // ... undo inventory reservation ...
}

async function refundPayment(orderId: string) {
  "use step";
  // ... refund the charge ...
}

export async function placeOrderSaga(orderId: string) {
  "use workflow";

  const rollbacks: Array<() => Promise<void>> = [];

  try {
    await reserveInventory(orderId);
    rollbacks.push(() => releaseInventory(orderId));

    await chargePayment(orderId);
    rollbacks.push(() => refundPayment(orderId));

    // ... more steps & rollbacks ...
  } catch (e) {
    for (const rollback of rollbacks.reverse()) {
      await rollback();
    }
    // Rethrow so the workflow records the failure after rollbacks
    throw e;
  }
}
```
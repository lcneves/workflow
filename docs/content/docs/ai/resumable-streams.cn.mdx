---
title: 可恢复流
---

在构建聊天界面时，经常会遇到网络中断、页面刷新或无服务器函数超时，这些情况会中断正在进行的代理连接。

在标准聊天实现中，用户通常需要重新发送消息并再次等待完整响应，而工作流运行是持久的，与其关联的流也是持久的。这意味着流可以在任何点恢复，且可以选择性地仅同步自上次连接以来丢失的数据。

可恢复流是 Workflow DevKit 的现成功能，但客户端需要能够识别存在的流、知道要重新连接到哪个流以及从何处开始。为此，Workflow DevKit 提供了 [`WorkflowChatTransport`](/docs/api-reference/workflow-ai/workflow-chat-transport) 帮助程序，这是 AI SDK 的一个可插拔传输，负责为您处理客户端的恢复逻辑。

## 实现流恢复

让我们为在 [构建持久的 AI 代理](/docs/ai) 指南中构建的航班预订代理添加流恢复功能。

<Steps>

<Step>

### 从您的 API 返回 Run ID

修改您的聊天端点，在响应头中包含工作流运行 ID。Run ID 唯一标识该运行的流，因此可以让客户端知道应重新连接到哪个流。

```typescript title="app/api/chat/route.ts" lineNumbers
// ... imports ...

export async function POST(req: Request) {

  // ... existing logic to create the workflow ...

  const run = await start(chatWorkflow, [modelMessages]);

  return createUIMessageStreamResponse({
    stream: run.readable,
    headers: { // [!code highlight
      "x-workflow-run-id": run.runId, // [!code highlight]
    }, // [!code highlight]
  });
}
```

</Step>

<Step>

### 添加流重连端点

当前我们只有一个始终创建新运行的 API 端点，因此需要创建一个新的 API 路由来返回现有运行的流：

```typescript title="app/api/chat/[id]/stream/route.ts" lineNumbers
import { createUIMessageStreamResponse } from "ai";
import { getRun } from "workflow/api"; // [!code highlight]

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const { searchParams } = new URL(request.url);

  // Client provides the last chunk index they received
  const startIndexParam = searchParams.get("startIndex"); // [!code highlight]
  const startIndex = startIndexParam
    ? parseInt(startIndexParam, 10)
    : undefined;

  // Instead of starting a new run, we fetch an existing run.
  const run = getRun(id); // [!code highlight]
  const stream = run.getReadable({ startIndex }); // [!code highlight]

  return createUIMessageStreamResponse({ stream }); // [!code highlight]
}
```

`startIndex` 参数确保客户端可以选择从流的何处恢复。例如，如果函数在流式传输期间超时，聊天传输将使用 `startIndex` 精确地从上次接收到的最后一个标记继续恢复流。

</Step>

<Step>

### 在客户端使用 `WorkflowChatTransport`

将 AI-SDK 的 `useChat` 中的默认传输替换为 [`WorkflowChatTransport`](/docs/api-reference/workflow-ai/workflow-chat-transport)，并更新回调以存储并使用最新的运行 ID。现在，我们将把运行 ID 存储在 localStorage 中。对于您自己的应用，这应存放在您存储会话信息的位置。

```typescript title="app/page.tsx" lineNumbers
"use client";

import { useChat } from "@ai-sdk/react";
import { WorkflowChatTransport } from "@workflow/ai"; // [!code highlight]
import { useMemo, useState } from "react";

export default function ChatPage() {

  // Check for an active workflow run on mount
  const activeRunId = useMemo(() => { // [!code highlight]
    if (typeof window === "undefined") return; // [!code highlight]
    return localStorage.getItem("active-workflow-run-id") ?? undefined; // [!code highlight]
  }, []); // [!code highlight]

  const { messages, sendMessage, status } = useChat({
    resume: Boolean(activeRunId), // [!code highlight]
    transport: new WorkflowChatTransport({ // [!code highlight]
      api: "/api/chat",

      // Store the run ID when a new chat starts
      onChatSendMessage: (response) => { // [!code highlight]
        const workflowRunId = response.headers.get("x-workflow-run-id"); // [!code highlight]
        if (workflowRunId) { // [!code highlight]
          localStorage.setItem("active-workflow-run-id", workflowRunId); // [!code highlight]
        } // [!code highlight]
      }, // [!code highlight]

      // Clear the run ID when the chat completes
      onChatEnd: () => { // [!code highlight]
        localStorage.removeItem("active-workflow-run-id"); // [!code highlight]
      }, // [!code highlight]

      // Use the stored run ID for reconnection
      prepareReconnectToStreamRequest: ({ api, ...rest }) => { // [!code highlight]
        const runId = localStorage.getItem("active-workflow-run-id"); // [!code highlight]
        if (!runId) throw new Error("No active workflow run ID found"); // [!code highlight]
        return { // [!code highlight]
          ...rest, // [!code highlight]
          api: `/api/chat/${encodeURIComponent(runId)}/stream`, // [!code highlight]
        }; // [!code highlight]
      }, // [!code highlight]
    }), // [!code highlight]
  });

  // ... render your chat UI
}
```

</Step>

</Steps>

现在再次尝试航班预订示例。可以在单独选项卡中打开，或频繁点击刷新按钮，观察客户端如何每次都连接到相同的聊天流。

## 工作原理

1. 当用户发送消息时，`WorkflowChatTransport` 向 `/api/chat` 发起 POST 请求
2. API 启动工作流并在 `x-workflow-run-id` 响应头中返回运行 ID
3. `onChatSendMessage` 将该运行 ID 存储到 localStorage
4. 如果在接收到“finish”块之前流被中断，传输会自动重新连接
5. `prepareReconnectToStreamRequest` 使用存储的运行 ID 构建重连 URL，指向新的端点 `/api/chat/{runId}/stream`
6. 重连端点从客户端离开的地方返回流
7. 当流完成时，`onChatEnd` 会清除存储的运行 ID

这种方法也能处理页面刷新，因为当 UI 加载并且存在存储的运行 ID 时，客户端会自动从最后已知位置重新连接到流，遵循 [AI SDK 的流恢复](https://ai-sdk.dev/docs/ai-sdk-ui/chatbot-resume-streams#chatbot-resume-streams) 的行为。

## 相关文档

- [`WorkflowChatTransport` API 参考](/docs/api-reference/workflow-ai/workflow-chat-transport) - 完整的配置选项
- [流式传输](/docs/foundations/streaming) - 了解工作流流式传输
- [`getRun()` API 参考](/docs/api-reference/workflow-api/get-run) - 检索已存在的运行
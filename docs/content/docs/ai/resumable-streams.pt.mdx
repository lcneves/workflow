---
title: Fluxos Retomáveis
---

Ao construir interfaces de chat, é comum enfrentar interrupções de rede, atualizações de página ou timeouts de funções serverless, que podem interromper a conexão com um agente em andamento.

Onde uma implementação de chat padrão exigiria que o usuário reenviassse sua mensagem e aguardasse toda a resposta novamente, as execuções de workflow são duráveis, assim como os streams anexados a elas. Isso significa que um stream pode ser retomado em qualquer ponto, opcionalmente sincronizando apenas os dados que foram perdidos desde a última conexão.

Streams retomáveis vêm prontos no Workflow DevKit, no entanto, o cliente precisa reconhecer que um stream existe, precisa saber a qual stream reconectar-se e precisa saber de onde começar. Para isso, o Workflow DevKit fornece o helper [`WorkflowChatTransport`](/docs/api-reference/workflow-ai/workflow-chat-transport), um transport plug-and-play para o AI SDK que lida com a lógica de retomada no lado do cliente para você.

## Implementando a retomada do fluxo

Vamos adicionar retomada de stream ao nosso Agente de Reserva de Voos que construímos no guia [Construindo Agentes de IA Duráveis](/docs/ai).

<Steps>

<Step>

### Retorne o Run ID da sua API

Modifique seu endpoint de chat para incluir o run ID do workflow em um cabeçalho de resposta. O Run ID identifica de forma única o stream da execução, então permite que o cliente saiba a qual stream reconectar-se.

```typescript title="app/api/chat/route.ts" lineNumbers
// ... imports ...

export async function POST(req: Request) {

  // ... existing logic to create the workflow ...

  const run = await start(chatWorkflow, [modelMessages]);

  return createUIMessageStreamResponse({
    stream: run.readable,
    headers: { // [!code highlight
      "x-workflow-run-id": run.runId, // [!code highlight]
    }, // [!code highlight]
  });
}
```

</Step>

<Step>

### Adicione um endpoint de reconexão do stream

Atualmente temos apenas um endpoint de API que sempre cria uma nova execução, então precisamos criar uma nova rota de API que retorne o stream de uma execução existente:

```typescript title="app/api/chat/[id]/stream/route.ts" lineNumbers
import { createUIMessageStreamResponse } from "ai";
import { getRun } from "workflow/api"; // [!code highlight]

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const { searchParams } = new URL(request.url);

  // Client provides the last chunk index they received
  const startIndexParam = searchParams.get("startIndex"); // [!code highlight]
  const startIndex = startIndexParam
    ? parseInt(startIndexParam, 10)
    : undefined;

  // Instead of starting a new run, we fetch an existing run.
  const run = getRun(id); // [!code highlight]
  const stream = run.getReadable({ startIndex }); // [!code highlight]

  return createUIMessageStreamResponse({ stream }); // [!code highlight]
}
```

O parâmetro `startIndex` garante que o cliente possa escolher de onde retomar o stream. Por exemplo, se a função expirar durante o streaming, o chat transport usará `startIndex` para retomar o stream exatamente a partir do último token recebido.

</Step>

<Step>

### Use `WorkflowChatTransport` no cliente

Substitua o transport padrão do `useChat` do AI-SDK por [`WorkflowChatTransport`](/docs/api-reference/workflow-ai/workflow-chat-transport) e atualize os callbacks para armazenar e usar o run ID mais recente. Por enquanto, vamos armazenar o run ID no localStorage. No seu próprio app, isso seria armazenado onde você guarda informações de sessão.

```typescript title="app/page.tsx" lineNumbers
"use client";

import { useChat } from "@ai-sdk/react";
import { WorkflowChatTransport } from "@workflow/ai"; // [!code highlight]
import { useMemo, useState } from "react";

export default function ChatPage() {

  // Check for an active workflow run on mount
  const activeRunId = useMemo(() => { // [!code highlight]
    if (typeof window === "undefined") return; // [!code highlight]
    return localStorage.getItem("active-workflow-run-id") ?? undefined; // [!code highlight]
  }, []); // [!code highlight]

  const { messages, sendMessage, status } = useChat({
    resume: Boolean(activeRunId), // [!code highlight]
    transport: new WorkflowChatTransport({ // [!code highlight]
      api: "/api/chat",

      // Store the run ID when a new chat starts
      onChatSendMessage: (response) => { // [!code highlight]
        const workflowRunId = response.headers.get("x-workflow-run-id"); // [!code highlight]
        if (workflowRunId) { // [!code highlight]
          localStorage.setItem("active-workflow-run-id", workflowRunId); // [!code highlight]
        } // [!code highlight]
      }, // [!code highlight]

      // Clear the run ID when the chat completes
      onChatEnd: () => { // [!code highlight]
        localStorage.removeItem("active-workflow-run-id"); // [!code highlight]
      }, // [!code highlight]

      // Use the stored run ID for reconnection
      prepareReconnectToStreamRequest: ({ api, ...rest }) => { // [!code highlight]
        const runId = localStorage.getItem("active-workflow-run-id"); // [!code highlight]
        if (!runId) throw new Error("No active workflow run ID found"); // [!code highlight]
        return { // [!code highlight]
          ...rest, // [!code highlight]
          api: `/api/chat/${encodeURIComponent(runId)}/stream`, // [!code highlight]
        }; // [!code highlight]
      }, // [!code highlight]
    }), // [!code highlight]
  });

  // ... render your chat UI
}
```

</Step>

</Steps>

Agora tente o exemplo de reserva de voos novamente. Abra-o em uma aba separada ou fique apertando o botão de atualizar e veja como o cliente se conecta ao mesmo stream de chat todas as vezes.

## Como funciona

1. Quando o usuário envia uma mensagem, o `WorkflowChatTransport` faz um POST para `/api/chat`
2. A API inicia um workflow e retorna o run ID no cabeçalho `x-workflow-run-id`
3. `onChatSendMessage` armazena esse run ID no localStorage
4. Se o stream for interrompido antes de receber um chunk "finish", o transport reconecta automaticamente
5. `prepareReconnectToStreamRequest` constrói a URL de reconexão usando o run ID armazenado, apontando para o novo endpoint `/api/chat/{runId}/stream`
6. O endpoint de reconexão retorna o stream a partir de onde o cliente parou
7. Quando o stream é concluído, `onChatEnd` remove o run ID armazenado

Essa abordagem também lida com atualizações de página, pois o cliente irá se reconectar automaticamente ao stream a partir da última posição conhecida quando a UI carregar com um run ID armazenado, seguindo o comportamento de retomada de stream do [AI SDK's stream resumption](https://ai-sdk.dev/docs/ai-sdk-ui/chatbot-resume-streams#chatbot-resume-streams).

## Documentação Relacionada

- [Referência da API de `WorkflowChatTransport`](/docs/api-reference/workflow-ai/workflow-chat-transport) - Opções completas de configuração
- [Streaming](/docs/foundations/streaming) - Entendendo os fluxos de workflow
- [Referência da API de `getRun()`](/docs/api-reference/workflow-api/get-run) - Recuperando execuções existentes
---
title: Keterlibatan Manusia (Human-in-the-Loop)
---

Prasyarat umum untuk menjalankan agen AI di produksi adalah kemampuan untuk menunggu input manusia atau kejadian eksternal sebelum melanjutkan.

Primitif [webhook](/docs/api-reference/workflow/create-webhook) dan [hook](/docs/api-reference/workflow/define-hook) dari Workflow DevKit memungkinkan pola *keterlibatan manusia* di mana workflow berhenti hingga seorang manusia mengambil tindakan, memungkinkan kelanjutan workflow yang mulus bahkan setelah berhari-hari tidak aktif, dan memberikan stabilitas di seluruh penyebaran kode.

Jika Anda perlu merespons kejadian eksternal secara programatik, lihat dokumentasi [hooks](/docs/foundations/hooks) untuk informasi lebih lanjut. Bagian panduan ini akan fokus pada pola keterlibatan manusia, yang merupakan subset dari pola hook yang lebih umum.

## Cara Kerjanya

<Steps>

<Step>
`defineHook()` membuat hook bertipe yang dapat di-await di dalam workflow. Saat tool dipanggil, ia membuat instance hook menggunakan ID pemanggilan tool sebagai token.
</Step>

<Step>
Workflow berhenti pada `await hook` - tidak ada sumber daya komputasi yang dikonsumsi saat menunggu manusia mengambil tindakan.
</Step>

<Step>
UI menampilkan panggilan tool yang tertunda beserta data inputnya (rincian penerbangan, harga, dll.) dan menampilkan kontrol persetujuan.
</Step>

<Step>
Pengguna mengirimkan keputusan mereka lewat endpoint API, yang melanjutkan hook dengan data persetujuan.
</Step>

<Step>
Workflow menerima data persetujuan dan melanjutkan eksekusi.
</Step>

</Steps>

Dalam demo ini akan digunakan tombol sisi klien untuk persetujuan manusia, tetapi Anda juga dapat membuat webhook dan mengirim tautan persetujuan melalui email atau Slack untuk melanjutkan agen.

## Membuat Alat Persetujuan Pemesanan

Tambahkan sebuah alat yang memungkinkan agen sengaja menghentikan eksekusi hingga seorang manusia menyetujui atau menolak pemesanan penerbangan:

<Steps>

<Step>

### Definisikan Hook

Buat hook bertipe dengan skema Zod untuk validasi:

```typescript title="workflow/steps/tools.ts" lineNumbers
import { defineHook } from "workflow";
import { z } from "zod";
// ... existing imports ...

export const bookingApprovalHook = defineHook({
  schema: z.object({
    approved: z.boolean(),
    comment: z.string().optional(),
  }),
});

// ... tool definitions ...
```

</Step>

<Step>

### Implementasikan Alat

Buat sebuah alat yang membuat instance hook menggunakan ID pemanggilan tool sebagai token. UI akan menggunakan ID ini untuk mengirimkan persetujuan.

```typescript title="workflows/chat/steps/tools.ts" lineNumbers
import { z } from "zod";

// ...

async function executeBookingApproval( // [!code highlight]
  { flightNumber, passengerName, price }: { flightNumber: string; passengerName: string; price: number }, // [!code highlight]
  { toolCallId }: { toolCallId: string } // [!code highlight]
) { // [!code highlight]
  // Note: No "use step" here - hooks are workflow-level primitives // [!code highlight]

  // Use the toolCallId as the hook token so the UI can reference it // [!code highlight]
  const hook = bookingApprovalHook.create({ token: toolCallId }); // [!code highlight]

  // Workflow pauses here until the hook is resolved // [!code highlight]
  const { approved, comment } = await hook; // [!code highlight]

  if (!approved) {
    return `Booking rejected: ${comment || "No reason provided"}`;
  }

  return `Booking approved for ${passengerName} on flight ${flightNumber}${comment ? ` - Note: ${comment}` : ""}`;
}

// Adding the tool to the existing tool definitions
export const flightBookingTools = {
  // ... existing tool definitions ...
  bookingApproval: {
    description: "Request human approval before booking a flight",
    inputSchema: z.object({
      flightNumber: z.string().describe("Flight number to book"),
      passengerName: z.string().describe("Name of the passenger"),
      price: z.number().describe("Total price of the booking"),
    }),
    execute: executeBookingApproval,
  },
};
```

<Callout type="info">
Perhatikan bahwa fungsi `defineHook().create()` harus dipanggil dari dalam konteks workflow, bukan dari dalam sebuah step. Inilah mengapa `executeBookingApproval` tidak memiliki `"use step"` - fungsi ini berjalan di konteks workflow di mana hook tersedia.
</Callout>

</Step>

<Step>

### Buat Rute API

Buat endpoint API baru yang akan dipanggil UI untuk mengirimkan keputusan persetujuan:

```typescript title="app/api/approve-booking/route.ts" lineNumbers
import { bookingApprovalHook } from "@/workflow/steps/tools";

export async function POST(request: Request) {
  const { toolCallId, approved, comment } = await request.json();

  // Schema validation happens automatically // [!code highlight]
  // Can throw a zod schema validation error, or a
  await bookingApprovalHook.resume(toolCallId, { // [!code highlight]
    approved,
    comment,
  });

  return Response.json({ success: true });
}
```

</Step>

<Step>

### Buat Komponen Persetujuan

Bangun sebuah komponen baru yang merespons data pemanggilan tool, dan memungkinkan pengguna untuk menyetujui atau menolak pemesanan:

```typescript title="components/booking-approval.tsx" lineNumbers
"use client";

import { useState } from "react";

interface BookingApprovalProps {
  toolCallId: string;
  input: {
    flightNumber: string;
    passengerName: string;
    price: number;
  };
  output?: string;
}

export function BookingApproval({ toolCallId, input, output }: BookingApprovalProps) {
  const [comment, setComment] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  // If we have output, the approval has been processed
  if (output) {
    return (
      <div className="border rounded-lg p-4">
        <p className="text-sm text-muted-foreground">{output}</p>
      </div>
    );
  }

  const handleSubmit = async (approved: boolean) => {
    setIsSubmitting(true);
    try {
      await fetch("/api/approve-booking", { // [!code highlight]
        method: "POST", // [!code highlight]
        headers: { "Content-Type": "application/json" }, // [!code highlight]
        body: JSON.stringify({ toolCallId, approved, comment }), // [!code highlight]
      }); // [!code highlight]
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="border rounded-lg p-4 space-y-4">
      <div className="space-y-2">
        <p className="font-medium">Approve this booking?</p>
        <div className="text-sm text-muted-foreground">
          <div>Flight: {input.flightNumber}</div>
          <div>Passenger: {input.passengerName}</div>
          <div>Price: ${input.price}</div>
        </div>
      </div>

      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        placeholder="Add a comment (optional)..."
        className="w-full border rounded p-2 text-sm"
        rows={2}
      />

      <div className="flex gap-2">
        <button
          onClick={() => handleSubmit(true)}
          disabled={isSubmitting}
          className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
        >
          {isSubmitting ? "Submitting..." : "Approve"}
        </button>
        <button
          onClick={() => handleSubmit(false)}
          disabled={isSubmitting}
          className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50"
        >
          {isSubmitting ? "Submitting..." : "Reject"}
        </button>
      </div>
    </div>
  );
}
```

</Step>

<Step>

### Tampilkan Status Alat di UI

Gunakan komponen yang baru saja kita buat untuk merender pemanggilan tool dan kontrol persetujuan di antarmuka chat Anda:

```typescript title="app/page.tsx" lineNumbers
// ... existing imports ...
import { BookingApproval } from "@/components/booking-approval";

export default function ChatPage() {

  // ...

  const { stop, messages, sendMessage, status, setMessages } =
    useChat<MyUIMessage>({
      // ... options
    });

  // ...

  return (
    <div className="flex flex-col w-full max-w-2xl pt-12 pb-24 mx-auto stretch">
      // ...

      <Conversation className="mb-10">
        <ConversationContent>
          {messages.map((message, index) => {
            const hasText = message.parts.some((part) => part.type === "text");

            return (
              <div key={message.id}>
                // ...
                <Message from={message.role}>
                  <MessageContent>
                    {message.parts.map((part, partIndex) => {

                      // ...

                      if (
                        part.type === "tool-searchFlights" ||
                        part.type === "tool-checkFlightStatus" ||
                        part.type === "tool-getAirportInfo" ||
                        part.type === "tool-bookFlight" ||
                        part.type === "tool-checkBaggageAllowance"
                      ) {
                        // ... render other tools
                      }
                      if (part.type === "tool-bookingApproval") { // [!code highlight]
                        return ( // [!code highlight]
                          <BookingApproval // [!code highlight]
                            key={partIndex} // [!code highlight]
                            toolCallId={part.toolCallId} // [!code highlight]
                            input={part.input} // [!code highlight]
                            output={part.output} // [!code highlight]
                          /> // [!code highlight]
                        ); // [!code highlight]
                      } // [!code highlight]
                      return null;
                    })}
                  </MessageContent>
                </Message>
              </div>
            );
          })}
        </ConversationContent>
        <ConversationScrollButton />
      </Conversation>

      // ...
    </div>
  );
}
```

</Step>

</Steps>

## Menggunakan Webhook Secara Langsung

Untuk kasus yang lebih sederhana di mana Anda tidak memerlukan validasi bertipe atau kelanjutan programatik, Anda dapat menggunakan [`createWebhook()`](/docs/api-reference/workflow/create-webhook) secara langsung. Ini menghasilkan URL unik yang dapat dipanggil untuk melanjutkan workflow:

```typescript title="workflows/chat/steps/tools.ts" lineNumbers
import { createWebhook } from "workflow";
import { z } from "zod";

async function executeBookingApproval(
  { flightNumber, passengerName, price }: { flightNumber: string; passengerName: string; price: number },
  { toolCallId }: { toolCallId: string }
) {
  const webhook = createWebhook(); // [!code highlight]

  // The webhook URL could be logged, sent via email, or stored for later use
  console.log("Approval URL:", webhook.url);

  // Workflow pauses here until the webhook is called // [!code highlight]
  const request = await webhook; // [!code highlight]
  const { approved, comment } = await request.json(); // [!code highlight]

  if (!approved) {
    return `Booking rejected: ${comment || "No reason provided"}`;
  }

  return `Booking approved for ${passengerName} on flight ${flightNumber}`;
}
```

URL webhook dapat dipanggil langsung dengan permintaan POST yang berisi data persetujuan. Ini berguna untuk:

- Sistem eksternal yang perlu memanggil balik ke workflow Anda
- Callback penyedia pembayaran
- Tautan persetujuan berbasis email

## Dokumentasi Terkait

- [Hooks & Webhooks](/docs/foundations/hooks) - Panduan lengkap tentang hooks dan webhooks
- [`createWebhook()` Referensi API](/docs/api-reference/workflow/create-webhook) - Opsi konfigurasi webhook
- [`defineHook()` Referensi API](/docs/api-reference/workflow/define-hook) - Definisi hook yang bertipe secara aman
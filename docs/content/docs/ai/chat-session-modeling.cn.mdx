---
title: 聊天会话建模
---

AI 代理中的聊天会话可以在架构的不同层面进行建模。选择会影响状态的归属以及如何处理中断和重连。

虽然有许多方式来建模聊天会话，但两种最常见的类别是单回合和多回合。

## 单回合工作流

每条用户消息都会触发一次新的工作流运行。客户端或 API 路由拥有会话历史，并在每次请求时发送完整的消息数组。

<Tabs items={['工作流', 'API 路由', '客户端']}>

<Tab value="工作流">

```typescript title="workflows/chat/workflow.ts" lineNumbers
import { DurableAgent } from "@workflow/ai/agent";
import { getWritable } from "workflow";
import { flightBookingTools, FLIGHT_ASSISTANT_PROMPT } from "./steps/tools";
import type { ModelMessage, UIMessageChunk } from "ai";

export async function chatWorkflow(messages: ModelMessage[]) {
  "use workflow";

  const writable = getWritable<UIMessageChunk>();

  const agent = new DurableAgent({
    model: "bedrock/claude-4-5-haiku-20251001-v1",
    system: FLIGHT_ASSISTANT_PROMPT,
    tools: flightBookingTools,
  });

  const { messages: result } = await agent.stream({
    messages, // [!code highlight] Full history from client
    writable,
  });

  return { messages: result };
}
```

</Tab>

<Tab value="API 路由">

```typescript title="app/api/chat/route.ts" lineNumbers
import type { UIMessage } from "ai";
import { createUIMessageStreamResponse, convertToModelMessages } from "ai";
import { start } from "workflow/api";
import { chatWorkflow } from "@/workflows/chat/workflow";

export async function POST(req: Request) {
  const { messages }: { messages: UIMessage[] } = await req.json();
  const modelMessages = convertToModelMessages(messages);

  const run = await start(chatWorkflow, [modelMessages]); // [!code highlight]

  return createUIMessageStreamResponse({
    stream: run.readable,
  });
}
```

</Tab>

<Tab value="客户端">

Chat messages need to be stored somewhere—typically a database. In this example, we assume a route like `/chats/:id` passes the session ID, allowing us to fetch existing messages and persist new ones.

```typescript title="app/chats/[id]/page.tsx" lineNumbers
"use client";

import { useChat } from "@ai-sdk/react";
import { WorkflowChatTransport } from "@workflow/ai"; // [!code highlight]
import { useParams } from "next/navigation";
import { useMemo } from "react";

// Fetch existing messages from your backend
async function getMessages(sessionId: string) { // [!code highlight]
  const res = await fetch(`/api/chats/${sessionId}/messages`); // [!code highlight]
  return res.json(); // [!code highlight]
} // [!code highlight]

export function Chat({ initialMessages }) {
  const { id: sessionId } = useParams<{ id: string }>();

  const transport = useMemo( // [!code highlight]
    () => // [!code highlight]
      new WorkflowChatTransport({ // [!code highlight]
        api: "/api/chat", // [!code highlight]
        onChatEnd: async () => { // [!code highlight]
          // Persist the updated messages to the chat session // [!code highlight]
          await fetch(`/api/chats/${sessionId}/messages`, { // [!code highlight]
            method: "PUT", // [!code highlight]
            headers: { "Content-Type": "application/json" }, // [!code highlight]
            body: JSON.stringify({ messages }), // [!code highlight]
          }); // [!code highlight]
        }, // [!code highlight]
      }), // [!code highlight]
    [sessionId] // [!code highlight]
  ); // [!code highlight]

  const { messages, input, handleInputChange, handleSubmit } = useChat({
    initialMessages, // [!code highlight] Loaded via getMessages(sessionId)
    transport, // [!code highlight]
  });

  return (
    <form onSubmit={handleSubmit}>
      {/* ... render messages ... */}
      <input value={input} onChange={handleInputChange} />
    </form>
  );
}
```

</Tab>

</Tabs>

在此模式中，客户端拥有会话状态，最新回合由 AI SDK 的 `useChat` 管理，过去的回合则持久化到后端。当前回合要么通过可恢复流由工作流管理（参见 [可恢复流](/docs/ai/resumable-streams)），要么通过 `useChat` 的钩子在消息到达时将每条新消息持久化到后端。

这是 [构建持久化 AI 代理](/docs/ai) 指南中使用的模式。

## 多回合工作流

单个工作流处理跨多个回合的整个会话，并拥有当前会话状态。客户端/API 路由通过钩子注入新消息。

<Tabs items={['工作流', 'API 路由', 'Hook 定义', '客户端']}>

<Tab value="工作流">

```typescript title="workflows/chat/workflow.ts" lineNumbers
import { DurableAgent } from "@workflow/ai/agent";
import { getWritable } from "workflow";
import { chatMessageHook } from "./hooks/chat-message";
import { flightBookingTools, FLIGHT_ASSISTANT_PROMPT } from "./steps/tools";
import type { ModelMessage, UIMessageChunk } from "ai";

export async function chatWorkflow(threadId: string, initialMessage: string) {
  "use workflow";

  const writable = getWritable<UIMessageChunk>();
  const messages: ModelMessage[] = [{ role: "user", content: initialMessage }];

  const agent = new DurableAgent({
    model: "bedrock/claude-4-5-haiku-20251001-v1",
    system: FLIGHT_ASSISTANT_PROMPT,
    tools: flightBookingTools,
  });

  // Create hook with thread-specific token for resumption // [!code highlight]
  const hook = chatMessageHook.create({ token: `thread:${threadId}` }); // [!code highlight]

  while (true) {
    // Process current messages
    const { messages: result } = await agent.stream({
      messages,
      writable,
      preventClose: true, // [!code highlight] Keep stream open for follow-ups
    });
    messages.push(...result.slice(messages.length));

    // Wait for next user message // [!code highlight]
    const { message } = await hook; // [!code highlight]
    if (message === "/done") break;

    messages.push({ role: "user", content: message });
  }

  return { messages };
}
```

</Tab>

<Tab value="API 路由">

Two endpoints: one to start the session, one to send follow-up messages.

```typescript title="app/api/chat/route.ts" lineNumbers
import { createUIMessageStreamResponse } from "ai";
import { start } from "workflow/api";
import { chatWorkflow } from "@/workflows/chat/workflow";

export async function POST(req: Request) {
  const { threadId, message } = await req.json();

  const run = await start(chatWorkflow, [threadId, message]); // [!code highlight]

  return createUIMessageStreamResponse({
    stream: run.readable,
  });
}
```

```typescript title="app/api/chat/[id]/route.ts" lineNumbers
import { chatMessageHook } from "@/workflows/chat/hooks/chat-message";

export async function POST(
  req: Request,
  { params }: { params: Promise<{ id: string }> }) // [!code highlight]
{
  const { message } = await req.json();
  const { id: threadId } = await params; // [!code highlight]

  await chatMessageHook.resume(`thread:${threadId}`, { message }); // [!code highlight]

  return Response.json({ success: true });
}
```

</Tab>

<Tab value="Hook 定义">

```typescript title="workflows/chat/hooks/chat-message.ts" lineNumbers
import { defineHook } from "workflow";
import { z } from "zod";

export const chatMessageHook = defineHook({
  schema: z.object({
    message: z.string(),
  }),
});
```

</Tab>

<Tab value="useMultiTurnChat 辅助函数">

We can replace our `useChat` react hook with a custom hook that manages the chat session. This hook will handle switching between the API endpoints for creating a new thread and sending follow-up messages.

```typescript title="hooks/use-multi-turn-chat.ts" lineNumbers
"use client";

import type { UIMessage } from "ai";
import { useChat } from "@ai-sdk/react"; // [!code highlight]
import { WorkflowChatTransport } from "@workflow/ai"; // [!code highlight]
import { useState, useCallback, useMemo } from "react";

export function useMultiTurnChat() {
  const [threadId, setThreadId] = useState<string | null>(null);

  const transport = useMemo( // [!code highlight]
    () => // [!code highlight]
      new WorkflowChatTransport({ // [!code highlight]
        api: "/api/chat", // [!code highlight]
      }), // [!code highlight]
    [] // [!code highlight]
  ); // [!code highlight]

  const {
    messages,
    sendMessage: sendInitialMessage, // [!code highlight] Renamed from sendMessage
    ...chatProps
  } = useChat({ transport }); // [!code highlight]

  const startSession = useCallback(
    async (message: UIMessage) => {
      const newThreadId = crypto.randomUUID();
      setThreadId(newThreadId);

      // Send initial message with threadId in body // [!code highlight]
      await sendInitialMessage(message, { // [!code highlight]
        body: { threadId: newThreadId }, // [!code highlight]
      }); // [!code highlight]
    },
    [sendInitialMessage]
  );

  // Follow-up messages go through the hook resumption endpoint // [!code highlight]
  const sendMessage = useCallback(
    async (message: UIMessage) => {
      if (!threadId) return;

      await fetch(`/api/chat/${threadId}`, { // [!code highlight]
        method: "POST", // [!code highlight]
        headers: { "Content-Type": "application/json" }, // [!code highlight]
        body: JSON.stringify({ message }), // [!code highlight]
      }); // [!code highlight]
    },
    [threadId]
  );

  const endSession = useCallback(async () => {
    if (!threadId) return;
    await sendMessage("/done");
    setThreadId(null);
  }, [threadId, sendMessage]);

  return { messages, threadId, startSession, sendMessage, endSession, ...chatProps };
}
```

</Tab>

</Tabs>

在此模式中，工作流拥有整个会话会话。所有消息都保存在工作流中，消息通过钩子注入到工作流中。当前回合和过去回合都可以通过重新连接到主工作流流在 UI 中可用。除了使用流之外，也可以在工作流端使用一步来持久化（并可能加载）来自外部存储的消息。使用外部数据库更具灵活性，但性能较低且比内置流更难优雅地恢复。

## 选择模式

| 考量 | 单回合 | 多回合 |
|------|--------|--------|
| 状态归属 | 客户端或 API 路由 | 工作流 |
| 后端注入消息 | 需要将多次运行拼接在一起 | 通过钩子原生支持 |
| 工作流复杂度 | 较低 | 较高 |
| 工作流时间范围 | 分钟级 | 小时到无限期 |
| 可观测范围 | 每回合追踪 | 全会话追踪 |

**对于大多数生产用例，推荐使用多回合。** 如果你是从头开始，选择多回合。它更灵活，能随着需求增长而扩展。你不需要自己维护聊天历史，可以将其全部卸载到工作流的内置持久化。此外，它还支持原生消息注入和完整会话的可观测性，随着代理的成熟这将变得越来越有价值。

**当改造现有架构时，单回合表现良好。** 如果你已经有一套管理消息状态的系统，并想逐步采用持久化代理，单回合工作流可以以最小改动插入。每个回合可以清晰地映射为独立的工作流运行。

## 多人聊天会话

多回合模式也能很容易地支持多人聊天会话。新消息可以来自系统事件、外部服务和其他用户。由于 `hook` 可以在任意时刻将消息注入到工作流中，而且整个历史是一个客户端可以重新连接的单一流，因此注入消息的来源并不重要。以下是多人聊天会话的不同用例：

<Tabs items={['系统事件', '外部服务', '多个用户']}>

<Tab value="系统事件">

Internal system events like scheduled tasks, background jobs, or database triggers can inject updates into an active conversation.

```typescript title="app/api/internal/flight-update/route.ts" lineNumbers
import { chatMessageHook } from "@/workflows/chat/hooks/chat-message";

// Called by your flight status monitoring system
export async function POST(req: Request) {
  const { threadId, flightNumber, newStatus } = await req.json();

  await chatMessageHook.resume(`thread:${threadId}`, { // [!code highlight]
    message: `[System] Flight ${flightNumber} status updated: ${newStatus}`, // [!code highlight]
  }); // [!code highlight]

  return Response.json({ success: true });
}
```

</Tab>

<Tab value="外部服务">

External webhooks from third-party services (Stripe, Twilio, etc.) can notify the conversation of events.

```typescript title="app/api/webhooks/payment/route.ts" lineNumbers
import { chatMessageHook } from "@/workflows/chat/hooks/chat-message";

export async function POST(req: Request) {
  const { threadId, paymentStatus, amount } = await req.json();

  if (paymentStatus === "succeeded") {
    await chatMessageHook.resume(`thread:${threadId}`, { // [!code highlight]
      message: `[Payment] Payment of $${amount.toFixed(2)} received. Your booking is confirmed!`, // [!code highlight]
    }); // [!code highlight]
  }

  return Response.json({ received: true });
}
```

</Tab>

<Tab value="多个用户">

Multiple human users can participate in the same conversation. Each user's client connects to the same workflow stream.

```typescript title="app/api/chat/[id]/route.ts" lineNumbers
import { chatMessageHook } from "@/workflows/chat/hooks/chat-message";
import { getUser } from "@/lib/auth";

export async function POST(
  req: Request,
  { params }: { params: Promise<{ id: string }> } // [!code highlight]
) {
  const { id: threadId } = await params;
  const { message } = await req.json();
  const user = await getUser(req); // [!code highlight]

  // Inject message with user attribution // [!code highlight]
  await chatMessageHook.resume(`thread:${threadId}`, { // [!code highlight]
    message: `[${user.name}] ${message}`, // [!code highlight]
  }); // [!code highlight]

  return Response.json({ success: true });
}
```

</Tab>

</Tabs>

## 相关文档

- [构建持久化 AI 代理](/docs/ai) - 持久化代理的基础指南
- [消息排队](/docs/ai/message-queueing) - 在工具执行期间对消息进行排队
- [`defineHook()` API 参考](/docs/api-reference/workflow/define-hook) - 钩子配置选项
- [`DurableAgent` API 参考](/docs/api-reference/workflow-ai/durable-agent) - 完整 API 文档
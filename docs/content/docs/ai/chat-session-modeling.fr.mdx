---
title: Modélisation des sessions de chat
---

Les sessions de chat dans les agents IA peuvent être modélisées à différents niveaux de votre architecture. Le choix influence la propriété de l'état et la manière dont vous gérez les interruptions et les reconnexions.

Bien qu'il existe de nombreuses façons de modéliser les sessions de chat, les deux catégories les plus courantes sont les workflows à un seul tour et les workflows à plusieurs tours.

## Workflows à un seul tour

Chaque message utilisateur déclenche une nouvelle exécution de workflow. Le client ou la route API possède l'historique de conversation et envoie le tableau complet de messages à chaque requête.

<Tabs items={['Workflow', 'API Route', 'Client']}>

<Tab value="Workflow">

```typescript title="workflows/chat/workflow.ts" lineNumbers
import { DurableAgent } from "@workflow/ai/agent";
import { getWritable } from "workflow";
import { flightBookingTools, FLIGHT_ASSISTANT_PROMPT } from "./steps/tools";
import type { ModelMessage, UIMessageChunk } from "ai";

export async function chatWorkflow(messages: ModelMessage[]) {
  "use workflow";

  const writable = getWritable<UIMessageChunk>();

  const agent = new DurableAgent({
    model: "bedrock/claude-4-5-haiku-20251001-v1",
    system: FLIGHT_ASSISTANT_PROMPT,
    tools: flightBookingTools,
  });

  const { messages: result } = await agent.stream({
    messages, // [!code highlight] Full history from client
    writable,
  });

  return { messages: result };
}
```

</Tab>

<Tab value="API Route">

```typescript title="app/api/chat/route.ts" lineNumbers
import type { UIMessage } from "ai";
import { createUIMessageStreamResponse, convertToModelMessages } from "ai";
import { start } from "workflow/api";
import { chatWorkflow } from "@/workflows/chat/workflow";

export async function POST(req: Request) {
  const { messages }: { messages: UIMessage[] } = await req.json();
  const modelMessages = convertToModelMessages(messages);

  const run = await start(chatWorkflow, [modelMessages]); // [!code highlight]

  return createUIMessageStreamResponse({
    stream: run.readable,
  });
}
```

</Tab>

<Tab value="Client">

Chat messages need to be stored somewhere—typically a database. In this example, we assume a route like `/chats/:id` passes the session ID, allowing us to fetch existing messages and persist new ones.

```typescript title="app/chats/[id]/page.tsx" lineNumbers
"use client";

import { useChat } from "@ai-sdk/react";
import { WorkflowChatTransport } from "@workflow/ai"; // [!code highlight]
import { useParams } from "next/navigation";
import { useMemo } from "react";

// Fetch existing messages from your backend
async function getMessages(sessionId: string) { // [!code highlight]
  const res = await fetch(`/api/chats/${sessionId}/messages`); // [!code highlight]
  return res.json(); // [!code highlight]
} // [!code highlight]

export function Chat({ initialMessages }) {
  const { id: sessionId } = useParams<{ id: string }>();

  const transport = useMemo( // [!code highlight]
    () => // [!code highlight]
      new WorkflowChatTransport({ // [!code highlight]
        api: "/api/chat", // [!code highlight]
        onChatEnd: async () => { // [!code highlight]
          // Persist the updated messages to the chat session // [!code highlight]
          await fetch(`/api/chats/${sessionId}/messages`, { // [!code highlight]
            method: "PUT", // [!code highlight]
            headers: { "Content-Type": "application/json" }, // [!code highlight]
            body: JSON.stringify({ messages }), // [!code highlight]
          }); // [!code highlight]
        }, // [!code highlight]
      }), // [!code highlight]
    [sessionId] // [!code highlight]
  ); // [!code highlight]

  const { messages, input, handleInputChange, handleSubmit } = useChat({
    initialMessages, // [!code highlight] Loaded via getMessages(sessionId)
    transport, // [!code highlight]
  });

  return (
    <form onSubmit={handleSubmit}>
      {/* ... render messages ... */}
      <input value={input} onChange={handleInputChange} />
    </form>
  );
}
```

</Tab>

</Tabs>

Dans ce modèle, le client possède l'état de la conversation, le dernier tour étant géré par le hook `useChat` du SDK AI, et les tours précédents sont persistés dans le backend. Le tour courant est soit géré via le workflow par un flux résumable (voir [Flux résumables](/docs/ai/resumable-streams)), soit un hook lié à `useChat` persiste chaque nouveau message dans le backend, au fur et à mesure de leur arrivée.

C'est le modèle utilisé dans le guide [Créer des agents IA durables](/docs/ai).

## Workflows à plusieurs tours

Un seul workflow gère toute la session de conversation sur plusieurs tours et possède l'état courant de la conversation. Les clients / routes API injectent de nouveaux messages via des hooks.

<Tabs items={['Workflow', 'API Routes', 'Hook Definition', 'Client']}>

<Tab value="Workflow">

```typescript title="workflows/chat/workflow.ts" lineNumbers
import { DurableAgent } from "@workflow/ai/agent";
import { getWritable } from "workflow";
import { chatMessageHook } from "./hooks/chat-message";
import { flightBookingTools, FLIGHT_ASSISTANT_PROMPT } from "./steps/tools";
import type { ModelMessage, UIMessageChunk } from "ai";

export async function chatWorkflow(threadId: string, initialMessage: string) {
  "use workflow";

  const writable = getWritable<UIMessageChunk>();
  const messages: ModelMessage[] = [{ role: "user", content: initialMessage }];

  const agent = new DurableAgent({
    model: "bedrock/claude-4-5-haiku-20251001-v1",
    system: FLIGHT_ASSISTANT_PROMPT,
    tools: flightBookingTools,
  });

  // Create hook with thread-specific token for resumption // [!code highlight]
  const hook = chatMessageHook.create({ token: `thread:${threadId}` }); // [!code highlight]

  while (true) {
    // Process current messages
    const { messages: result } = await agent.stream({
      messages,
      writable,
      preventClose: true, // [!code highlight] Keep stream open for follow-ups
    });
    messages.push(...result.slice(messages.length));

    // Wait for next user message // [!code highlight]
    const { message } = await hook; // [!code highlight]
    if (message === "/done") break;

    messages.push({ role: "user", content: message });
  }

  return { messages };
}
```

</Tab>

<Tab value="API Routes">

Two endpoints: one to start the session, one to send follow-up messages.

```typescript title="app/api/chat/route.ts" lineNumbers
import { createUIMessageStreamResponse } from "ai";
import { start } from "workflow/api";
import { chatWorkflow } from "@/workflows/chat/workflow";

export async function POST(req: Request) {
  const { threadId, message } = await req.json();

  const run = await start(chatWorkflow, [threadId, message]); // [!code highlight]

  return createUIMessageStreamResponse({
    stream: run.readable,
  });
}
```

```typescript title="app/api/chat/[id]/route.ts" lineNumbers
import { chatMessageHook } from "@/workflows/chat/hooks/chat-message";

export async function POST(
  req: Request,
  { params }: { params: Promise<{ id: string }> }) // [!code highlight]
{
  const { message } = await req.json();
  const { id: threadId } = await params; // [!code highlight]

  await chatMessageHook.resume(`thread:${threadId}`, { message }); // [!code highlight]

  return Response.json({ success: true });
}
```

</Tab>

<Tab value="Hook Definition">

```typescript title="workflows/chat/hooks/chat-message.ts" lineNumbers
import { defineHook } from "workflow";
import { z } from "zod";

export const chatMessageHook = defineHook({
  schema: z.object({
    message: z.string(),
  }),
});
```

</Tab>

<Tab value="useMultiTurnChat helpers">

We can replace our `useChat` react hook with a custom hook that manages the chat session. This hook will handle switching between the API endpoints for creating a new thread and sending follow-up messages.

```typescript title="hooks/use-multi-turn-chat.ts" lineNumbers
"use client";

import type { UIMessage } from "ai";
import { useChat } from "@ai-sdk/react"; // [!code highlight]
import { WorkflowChatTransport } from "@workflow/ai"; // [!code highlight]
import { useState, useCallback, useMemo } from "react";

export function useMultiTurnChat() {
  const [threadId, setThreadId] = useState<string | null>(null);

  const transport = useMemo( // [!code highlight]
    () => // [!code highlight]
      new WorkflowChatTransport({ // [!code highlight]
        api: "/api/chat", // [!code highlight]
      }), // [!code highlight]
    [] // [!code highlight]
  ); // [!code highlight]

  const {
    messages,
    sendMessage: sendInitialMessage, // [!code highlight] Renamed from sendMessage
    ...chatProps
  } = useChat({ transport }); // [!code highlight]

  const startSession = useCallback(
    async (message: UIMessage) => {
      const newThreadId = crypto.randomUUID();
      setThreadId(newThreadId);

      // Send initial message with threadId in body // [!code highlight]
      await sendInitialMessage(message, { // [!code highlight]
        body: { threadId: newThreadId }, // [!code highlight]
      }); // [!code highlight]
    },
    [sendInitialMessage]
  );

  // Follow-up messages go through the hook resumption endpoint // [!code highlight]
  const sendMessage = useCallback(
    async (message: UIMessage) => {
      if (!threadId) return;

      await fetch(`/api/chat/${threadId}`, { // [!code highlight]
        method: "POST", // [!code highlight]
        headers: { "Content-Type": "application/json" }, // [!code highlight]
        body: JSON.stringify({ message }), // [!code highlight]
      }); // [!code highlight]
    },
    [threadId]
  );

  const endSession = useCallback(async () => {
    if (!threadId) return;
    await sendMessage("/done");
    setThreadId(null);
  }, [threadId, sendMessage]);

  return { messages, threadId, startSession, sendMessage, endSession, ...chatProps };
}
```

</Tab>

</Tabs>

Dans ce modèle, le workflow possède l'intégralité de la session de conversation. Tous les messages sont persistés dans le workflow, et les messages sont injectés dans le workflow via des hooks. Les tours **et** les tours précédents sont disponibles dans l'interface utilisateur en se reconnectant au flux principal du workflow. En alternative au flux, il est également possible d'utiliser une étape côté workflow pour persister (et éventuellement charger) les messages depuis un stockage externe. L'utilisation d'une base de données externe est plus flexible, mais moins performante et plus difficile à reprendre proprement que le flux intégré.

## Choisir un modèle

| Critère | Un seul tour | Plusieurs tours |
|--------------|-------------|------------|
| Propriété de l'état | Client ou route API | Workflow |
| Injection de messages depuis le backend | Nécessite d'assembler plusieurs exécutions | Natif via des hooks |
| Complexité du workflow | Moindre | Plus élevée |
| Horizon temporel du workflow | Minutes | De quelques heures à indéfiniment |
| Portée de l'observabilité | Traces par tour | Traces de session complètes |

**Le modèle à plusieurs tours est recommandé pour la plupart des cas d'utilisation en production.** Si vous commencez un nouveau projet, optez pour le modèle à plusieurs tours. Il est plus flexible et évolue avec vos besoins. Vous n'avez pas besoin de maintenir vous-même l'historique du chat et pouvez déléguer cela à la persistance intégrée du workflow. Il permet également l'injection native de messages et une observabilité complète de la session, ce qui devient de plus en plus précieux à mesure que votre agent mûrit.

**Le modèle à un seul tour fonctionne bien lors de l'adaptation d'architectures existantes.** Si vous disposez déjà d'un système pour gérer l'état des messages et souhaitez adopter progressivement des agents durables, les workflows à un seul tour s'intègrent avec des changements minimaux. Chaque tour correspond proprement à une exécution de workflow indépendante.

## Sessions de chat multijoueurs

Le modèle à plusieurs tours permet également facilement les sessions de chat multijoueurs. De nouveaux messages peuvent provenir d'événements système, de services externes ou d'autres utilisateurs. Comme un `hook` injecte des messages dans le workflow à n'importe quel moment, et que l'historique complet est un flux unique auquel les clients peuvent se reconnecter, l'origine des messages injectés n'a pas d'importance. Voici différents cas d'utilisation pour les sessions de chat multijoueurs :

<Tabs items={['System Event', 'External Service', 'Multiple Users']}>

<Tab value="System Event">

Internal system events like scheduled tasks, background jobs, or database triggers can inject updates into an active conversation.

```typescript title="app/api/internal/flight-update/route.ts" lineNumbers
import { chatMessageHook } from "@/workflows/chat/hooks/chat-message";

// Called by your flight status monitoring system
export async function POST(req: Request) {
  const { threadId, flightNumber, newStatus } = await req.json();

  await chatMessageHook.resume(`thread:${threadId}`, { // [!code highlight]
    message: `[System] Flight ${flightNumber} status updated: ${newStatus}`, // [!code highlight]
  }); // [!code highlight]

  return Response.json({ success: true });
}
```

</Tab>

<Tab value="External Service">

External webhooks from third-party services (Stripe, Twilio, etc.) can notify the conversation of events.

```typescript title="app/api/webhooks/payment/route.ts" lineNumbers
import { chatMessageHook } from "@/workflows/chat/hooks/chat-message";

export async function POST(req: Request) {
  const { threadId, paymentStatus, amount } = await req.json();

  if (paymentStatus === "succeeded") {
    await chatMessageHook.resume(`thread:${threadId}`, { // [!code highlight]
      message: `[Payment] Payment of $${amount.toFixed(2)} received. Your booking is confirmed!`, // [!code highlight]
    }); // [!code highlight]
  }

  return Response.json({ received: true });
}
```

</Tab>

<Tab value="Multiple Users">

Multiple human users can participate in the same conversation. Each user's client connects to the same workflow stream.

```typescript title="app/api/chat/[id]/route.ts" lineNumbers
import { chatMessageHook } from "@/workflows/chat/hooks/chat-message";
import { getUser } from "@/lib/auth";

export async function POST(
  req: Request,
  { params }: { params: Promise<{ id: string }> } // [!code highlight]
) {
  const { id: threadId } = await params;
  const { message } = await req.json();
  const user = await getUser(req); // [!code highlight]

  // Inject message with user attribution // [!code highlight]
  await chatMessageHook.resume(`thread:${threadId}`, { // [!code highlight]
    message: `[${user.name}] ${message}`, // [!code highlight]
  }); // [!code highlight]

  return Response.json({ success: true });
}
```

</Tab>

</Tabs>

## Documentation associée

- [Créer des agents IA durables](/docs/ai) - Guide de base pour les agents durables
- [Mise en file d'attente des messages](/docs/ai/message-queueing) - Mise en file d'attente des messages pendant l'exécution des outils
- [`defineHook()` API Reference](/docs/api-reference/workflow/define-hook) - Options de configuration du hook
- [`DurableAgent` API Reference](/docs/api-reference/workflow-ai/durable-agent) - Documentation complète de l'API
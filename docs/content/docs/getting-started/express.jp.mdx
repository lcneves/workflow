---
title: Express
---

このガイドでは、Express アプリで最初のワークフローを設定する手順を説明します。途中で、開発キットを自身のプロジェクトで使用する際に重要となる基本概念についても学びます。

---

<Steps>

<Step>
## Express プロジェクトを作成する

まず新しい Express プロジェクトを作成します。

```bash
mkdir my-workflow-app
```

作成したディレクトリに移動します:

```bash
cd my-workflow-app
```

プロジェクトを初期化します:

```bash
npm init --y
```

### `workflow`、`express`、`nitro`、および `rollup` をインストールする

```package-install
npm i workflow express nitro rollup
```

<Callout>
デフォルトでは Express にはビルドシステムが含まれていません。Nitro を追加することで、ワークフローやランのコンパイル、開発および本番へのデプロイが可能になります。Nitro の詳細は[こちら](https://v3.nitro.build)を参照してください。
</Callout>

TypeScript を使用する場合は、`@types/express` パッケージをインストールする必要があります。

```bash
npm i -D @types/express
```

### Nitro の設定

`workflow/nitro` モジュールを使用する Nitro の設定として、新しいファイル `nitro.config.ts` を作成します。これにより `"use workflow"` と `"use step"` ディレクティブが使用可能になります。

```typescript title="nitro.config.ts" lineNumbers
import { defineNitroConfig } from "nitro/config";

export default defineNitroConfig({
  modules: ["workflow/nitro"],
  vercel: { entryFormat: "node" },
  routes: {
    "/**": { handler: "./src/index.ts", format: "node" },
  },
});
```

<Accordion type="single" collapsible>
  <AccordionItem value="typescript-intellisense" className="[&_h3]:my-0">
    <AccordionTrigger className="[&_p]:my-0 text-lg [&_p]:text-foreground">
      TypeScript の IntelliSense を設定する（オプション）
    </AccordionTrigger>
    <AccordionContent className="[&_p]:my-2">
IDE で補助的なヒントを有効にするには、`tsconfig.json` に workflow プラグインを設定します:

```json title="tsconfig.json" lineNumbers
{
  "compilerOptions": {
    // ... rest of your TypeScript config
    "plugins": [
      {
        "name": "workflow" // [!code highlight]
      }
    ]
  }
}
```

    </AccordionContent>

  </AccordionItem>
</Accordion>

### `package.json` を更新する

Nitro ビルダーを使用するには、次のスクリプトを含むように `package.json` を更新します:

```json title="package.json" lineNumbers
{
  // ...
  "scripts": {
    "dev": "nitro dev",
    "build": "nitro build"
  },
  // ...
}
```

</Step>

<Step>

## 最初のワークフローを作成する

最初のワークフローファイルを作成します:

```typescript title="workflows/user-signup.ts" lineNumbers
import { sleep } from "workflow";

export async function handleUserSignup(email: string) {
  "use workflow"; // [!code highlight]

  const user = await createUser(email);
  await sendWelcomeEmail(user);

  await sleep("5s"); // Pause for 5s - doesn't consume any resources
  await sendOnboardingEmail(user);

  return { userId: user.id, status: "onboarded" };
}
```

次にこれらの関数を記述しますが、その前にこのコードを見てみましょう:

- ディレクティブ `"use workflow"` を用いて **ワークフロー** 関数を定義します。ワークフロー関数は個々の **ステップ** を調整する _オーケストレーター_ と考えてください。
- Workflow DevKit の `sleep` 関数は、リソースを消費することなくワークフローの実行を一時停止することを可能にします。sleep は数秒、数時間、数日、場合によっては数か月に及ぶこともあります。

## ワークフローステップを作成する

それでは、先ほどの不足している関数を定義します。

```typescript title="workflows/user-signup.ts" lineNumbers
import { FatalError } from "workflow";

// Our workflow function defined earlier

async function createUser(email: string) {
  "use step"; // [!code highlight]

  console.log(`Creating user with email: ${email}`);

  // Full Node.js access - database calls, APIs, etc.
  return { id: crypto.randomUUID(), email };
}

async function sendWelcomeEmail(user: { id: string; email: string }) {
  "use step"; // [!code highlight]

  console.log(`Sending welcome email to user: ${user.id}`);

  if (Math.random() < 0.3) {
    // By default, steps will be retried for unhandled errors
    throw new Error("Retryable!");
  }
}

async function sendOnboardingEmail(user: { id: string; email: string }) {
  "use step"; // [!code highlight]

  if (!user.email.includes("@")) {
    // To skip retrying, throw a FatalError instead
    throw new FatalError("Invalid Email");
  }

  console.log(`Sending onboarding email to user: ${user.id}`);
}
```

このコードを見てみると:

- ビジネスロジックは **ステップ** 内に存在します。ステップが **ワークフロー** 内で呼び出されると、ワークフローが一時停止している間に別のリクエストで実行されるようキューに登録されます。これは `sleep` と同様の動作です。
- `sendWelcomeEmail` の例のように、ステップがエラーを投げた場合、そのステップは成功するまで（またはステップの最大リトライ回数に達するまで）自動的にリトライされます。
- エラーが意図的でリトライすべきでない場合、ステップは `FatalError` をスローすることができます。

<Callout>
ワークフロー、ステップ、およびイベントを一時停止または処理する他の方法については、[基礎](/docs/foundations) を参照してください。
</Callout>

</Step>

<Step>

## ルートハンドラを作成する

新しいワークフローを呼び出すために、Express アプリと `src/index.ts` に新しい API ルートハンドラを作成します。コードは以下の通りです:

```typescript title="src/index.ts"
import express from "express";
import { start } from "workflow/api";
import { handleUserSignup } from "../workflows/user-signup.js";

const app = express();
app.use(express.json());

app.post("/api/signup", async (req, res) => {
  const { email } = req.body;
  await start(handleUserSignup, [email]);
  return res.json({ message: "User signup workflow started" });
});

export default app;
```

このルートハンドラは、ワークフローをトリガーする `/api/signup` の `POST` エンドポイントを作成します。

</Step>

<Step>

## 開発環境で実行する

開発サーバーを起動するには、Express のルートディレクトリで次のコマンドをターミナルで実行します:

```bash
npm run dev
```

開発サーバーが起動したら、次のコマンドを実行してワークフローをトリガーできます:

```bash
curl -X POST --json '{"email":"hello@example.com"}' http://localhost:3000/api/signup
```

Express の開発サーバーログを確認して、ワークフローの実行および処理されているステップを確認してください。

さらに、ワークフローの実行やステップを詳細に確認するには、[Workflow DevKit の CLI または Web UI](/docs/observability) を使用できます。

```bash
# Open the observability Web UI
npx workflow web
# or if you prefer a terminal interface, use the CLI inspect command
npx workflow inspect runs
```

<img src="/o11y-ui.png" alt="Workflow DevKit の Web UI" />

</Step>

</Steps>

---

## 本番環境へのデプロイ

Workflow DevKit アプリは現時点では [Vercel](https://vercel.com/home) へのデプロイが最も適しており、特別な設定は不要です。

ワークフローを他の環境にデプロイする方法については、[デプロイ方法](/docs/deploying) のセクションを確認してください。

## 次のステップ

- [基礎](/docs/foundations) について詳しく学ぶ。
- 問題が発生したら [エラー](/docs/errors) を確認してください。
- [API リファレンス](/docs/api-reference) を参照してください。
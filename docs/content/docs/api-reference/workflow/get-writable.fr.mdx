---
title: getWritable
description: Récupère le flux inscriptible (writable) par défaut de l'exécution de workflow en cours.
---

Le flux inscriptible peut être obtenu dans les fonctions de workflow et passé aux steps, ou appelé directement à l'intérieur des fonctions de step pour écrire des données qui peuvent être lues en dehors du workflow en utilisant la propriété `readable` de [l'objet `Run`](/docs/api-reference/workflow-api/get-run).

Utilisez cette fonction dans vos workflows et steps pour produire une sortie en streaming pouvant être consommée par des clients en temps réel.

<Callout type="warn">
  Cette fonction ne peut être appelée que depuis une fonction de workflow ou une fonction step (fonctions avec la directive `"use workflow"` ou `"use step"`)
</Callout>

<Callout type="error">
  **Important :** Bien que vous puissiez appeler `getWritable()` à l'intérieur d'une fonction de workflow pour obtenir le flux, vous **ne pouvez pas interagir directement avec le flux** dans le contexte du workflow (par exemple, appeler `getWriter()`, `write()` ou `close()`). Le flux doit être passé aux fonctions de step en tant qu'arguments, ou les steps peuvent appeler `getWritable()` directement eux-mêmes.
</Callout>

```typescript lineNumbers
import { getWritable } from "workflow";

export async function myWorkflow() {
  "use workflow";

  // Get the writable stream
  const writable = getWritable(); // [!code highlight]

  // Pass it to a step function to interact with it
  await writeToStream(writable); // [!code highlight]
}

async function writeToStream(writable: WritableStream) {
  "use step";

  const writer = writable.getWriter();
  await writer.write(new TextEncoder().encode("Hello from workflow!"));
  writer.releaseLock();
  await writable.close();
}
```

## Signature de l'API

### Paramètres

<TSDoc
  definition={`
import { getWritable } from "workflow";
export default getWritable;`}
  showSections={["parameters"]}
/>

### Retour

<TSDoc
  definition={`
import { getWritable } from "workflow";
export default getWritable;`}
  showSections={["returns"]}
/>

Renvoie un `WritableStream<W>` où `W` est le type de données que vous prévoyez d'écrire dans le flux.

## Bon à savoir

- **Les fonctions de workflow ne peuvent qu'obtenir le flux** - Appelez `getWritable()` dans un workflow pour obtenir la référence au flux, mais vous ne pouvez pas appeler des méthodes comme `getWriter()`, `write()` ou `close()` directement dans le contexte du workflow.
- **Les fonctions de step peuvent interagir avec les flux** - Les steps peuvent recevoir le flux en argument ou appeler `getWritable()` directement, et ils peuvent interagir librement avec lui (écrire, fermer, etc.).
- Lorsqu'il est appelé depuis un workflow, le flux doit être passé en argument aux steps pour qu'ils puissent l'utiliser.
- Lorsqu'il est appelé depuis un step, il récupère directement le même flux à l'échelle du workflow.
- Libérez toujours le verrou du writer après avoir écrit pour éviter les fuites de ressources.
- Le flux peut écrire des données binaires (en utilisant `TextEncoder`) ou des objets structurés.
- Pensez à fermer le flux lorsque vous avez terminé pour signaler la complétion.

## Exemples

### Streaming de texte basique

Voici un exemple simple de streaming de données textuelles :

```typescript lineNumbers
import { sleep, getWritable } from "workflow";

export async function outputStreamWorkflow() {
  "use workflow";

  const writable = getWritable(); // [!code highlight]

  await sleep("1s");
  await stepWithOutputStream(writable);
  await sleep("1s");
  await stepCloseOutputStream(writable);

  return "done";
}

async function stepWithOutputStream(writable: WritableStream) {
  "use step";

  const writer = writable.getWriter();
  // Write binary data using TextEncoder
  await writer.write(new TextEncoder().encode("Hello, world!"));
  writer.releaseLock();
}

async function stepCloseOutputStream(writable: WritableStream) {
  "use step";

  // Close the stream to signal completion
  await writable.close();
}
```

### Appeler `getWritable()` à l'intérieur des steps

Vous pouvez également appeler `getWritable()` directement à l'intérieur des fonctions de step sans le passer en paramètre :

```typescript lineNumbers
import { sleep, getWritable } from "workflow";

export async function outputStreamFromStepWorkflow() {
  "use workflow";

  // No need to create or pass the stream - steps can get it themselves
  await sleep("1s");
  await stepWithOutputStreamInside();
  await sleep("1s");
  await stepCloseOutputStreamInside();

  return "done";
}

async function stepWithOutputStreamInside() {
  "use step";

  // Call getWritable() directly inside the step // [!code highlight]
  const writable = getWritable(); // [!code highlight]
  const writer = writable.getWriter();

  await writer.write(new TextEncoder().encode("Hello from step!"));
  writer.releaseLock();
}

async function stepCloseOutputStreamInside() {
  "use step";

  // Call getWritable() to get the same stream // [!code highlight]
  const writable = getWritable(); // [!code highlight]
  await writable.close();
}
```

### Utiliser des flux nommés dans les steps

Vous pouvez aussi utiliser des flux avec espace de noms (namespaces) lorsque vous appelez `getWritable()` depuis des steps :

```typescript lineNumbers
import { getWritable } from "workflow";

export async function multiStreamWorkflow() {
  "use workflow";

  // Steps will access both streams by namespace
  await writeToDefaultStream();
  await writeToNamedStream();
  await closeStreams();

  return "done";
}

async function writeToDefaultStream() {
  "use step";

  const writable = getWritable(); // Default stream
  const writer = writable.getWriter();
  await writer.write({ message: "Default stream data" });
  writer.releaseLock();
}

async function writeToNamedStream() {
  "use step";

  const writable = getWritable({ namespace: "logs" }); // [!code highlight]
  const writer = writable.getWriter();
  await writer.write({ log: "Named stream data" });
  writer.releaseLock();
}

async function closeStreams() {
  "use step";

  await getWritable().close(); // Close default stream
  await getWritable({ namespace: "logs" }).close(); // Close named stream
}
```

### Streaming de chat avancé

Voici un exemple plus complexe montrant comment vous pourriez streamer des réponses de chat IA :

```typescript lineNumbers
import { getWritable } from "workflow";
import { generateId, streamText, type UIMessageChunk } from "ai";

export async function chat(messages: UIMessage[]) {
  "use workflow";

  // Get typed writable stream for UI message chunks
  const writable = getWritable<UIMessageChunk>(); // [!code highlight]

  // Start the stream
  await startStream(writable);

  let currentMessages = [...messages];

  // Process messages in steps
  for (let i = 0; i < MAX_STEPS; i++) {
    const result = await streamTextStep(currentMessages, writable);
    currentMessages.push(result.messages);

    if (result.finishReason !== "tool-calls") {
      break;
    }
  }

  // End the stream
  await endStream(writable);
}

async function startStream(writable: WritableStream<UIMessageChunk>) {
  "use step";

  const writer = writable.getWriter();

  // Send start message
  writer.write({
    type: "start",
    messageMetadata: {
      createdAt: Date.now(),
      messageId: generateId(),
    },
  });

  writer.releaseLock();
}

async function streamTextStep(
  messages: UIMessage[],
  writable: WritableStream<UIMessageChunk>
) {
  "use step";

  const writer = writable.getWriter();

  // Call streamText from the AI SDK
  const result = streamText({
    model: "gpt-4",
    messages,
    /* other options */
  });

  // Pipe the AI stream into the writable stream
  const reader = result
    .toUIMessageStream({ sendStart: false, sendFinish: false })
    .getReader();

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    await writer.write(value);
  }

  reader.releaseLock();

  // Close the stream
  writer.close();
  writer.releaseLock();
}

async function endStream(writable: WritableStream<UIMessageChunk>) {
  "use step";

  // Close the stream to signal completion
  await writable.close();
}
```
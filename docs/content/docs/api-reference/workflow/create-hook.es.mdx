---
title: createHook
---

Crea un primitivo de hook de bajo nivel que se puede usar para reanudar una ejecución de flujo de trabajo con cargas útiles arbitrarias.

Los hooks permiten que sistemas externos envíen datos a un flujo de trabajo pausado sin las restricciones específicas de HTTP de los webhooks. Se identifican mediante un token y pueden recibir cualquier carga serializable.

```ts lineNumbers
import { createHook } from "workflow"

export async function hookWorkflow() {
  "use workflow";
  const hook = createHook();  // [!code highlight]
  const result = await hook; // Suspends the workflow until the hook is resumed
}
```

## Firma de la API

### Parámetros

<TSDoc
definition={`
import { createHook } from "workflow";
export default createHook;`
}
showSections={['parameters']}
/>

#### HookOptions

<TSDoc
definition={`
import type { HookOptions } from "workflow";
export default HookOptions;`
}
/>

### Devuelve

<TSDoc
definition={`
import { createHook } from "workflow";
export default createHook;`}
showSections={['returns']}
/>

#### Hook

<TSDoc
definition={`
import type { Hook } from "workflow";
export default Hook;`}
/>

El objeto `Hook` devuelto también implementa `AsyncIterable<T>`, lo que permite iterar sobre las cargas entrantes usando la sintaxis `for await...of`.

## Ejemplos

### Uso básico

Al crear un hook, puedes especificar un tipo de carga útil que se usará para la seguridad de tipos automática.

```typescript lineNumbers
import { createHook } from "workflow"

export async function approvalWorkflow() {
  "use workflow";

  const hook = createHook<{ approved: boolean; comment: string }>(); // [!code highlight]
  console.log("Send approval to token:", hook.token);

  const result = await hook;

  if (result.approved) {
    console.log("Approved with comment:", result.comment);
  }
}
```

### Personalización de tokens

Los tokens se usan para identificar un hook específico. Puedes personalizar el token para que sea más específico a un caso de uso.

```typescript lineNumbers
import { createHook } from "workflow";

export async function slackBotWorkflow(channelId: string) {
  "use workflow";

  // Token constructed from channel ID
  const hook = createHook<SlackMessage>({ // [!code highlight]
    token: `slack_webhook:${channelId}`, // [!code highlight]
  }); // [!code highlight]

  for await (const message of hook) {
    if (message.text === "/stop") {
      break;
    }
    await processMessage(message);
  }
}
```

### Esperar múltiples cargas útiles

También puedes esperar múltiples cargas útiles usando la sintaxis `for await...of`.

```typescript lineNumbers
import { createHook } from "workflow"

export async function collectHookWorkflow() {
  "use workflow";

  const hook = createHook<{ message: string; done?: boolean }>();

  const payloads = [];
  for await (const payload of hook) { // [!code highlight]
    payloads.push(payload);

    if (payload.done) break;
  }

  return payloads;
}
```

## Funciones relacionadas

- [`defineHook()`](/docs/api-reference/workflow/define-hook) - Ayudante de hook con tipado seguro
- [`resumeHook()`](/docs/api-reference/workflow-api/resume-hook) - Reanudar un hook con una carga útil
- [`createWebhook()`](/docs/api-reference/workflow/create-webhook) - Abstracción de webhook HTTP de alto nivel
---
title: defineHook
---

型安全なフックヘルパーを作成します。フックの作成と再開の間でペイロードの型が一貫していることを保証します。

これは[`createHook()`](/docs/api-reference/workflow/create-hook)と[`resumeHook()`](/docs/api-reference/workflow-api/resume-hook)の軽量なラッパーで、型の不一致を回避します。また、Zod や Valibot のような [Standard Schema v1](https://standardschema.dev) 準拠のバリデータを用いた、オプションのランタイム検証と変換もサポートします。

<Callout>
本番コードベースでは、より良い型安全性とオプションのランタイム検証のために `defineHook()` を `createHook()` の代わりに使用することを推奨します。
</Callout>

```ts lineNumbers
import { defineHook } from "workflow";

const nameHook = defineHook<{
  name: string;
}>();

export async function nameWorkflow() {
  "use workflow";

  const hook = nameHook.create();  // [!code highlight]
  const result = await hook; // Fully typed as { name: string }
  console.log("Name:", result.name);
}
```

## API シグネチャ

### パラメータ

<TSDoc
definition={`
import { defineHook } from "workflow";
export default defineHook;`}
showSections={['parameters']}
/>

### 返り値

<TSDoc
definition={`
interface DefineHook<T> {
  /**

* Creates a new hook with the defined payload type.
  */
  create: (options?: HookOptions) => Hook<T>;

  /**

* Resumes a hook by sending a payload with the defined type.
   */
  resume: (token: string, payload: T) => Promise<HookEntity | null>;
}
export default DefineHook;`}
/>

## 例

### 基本的な型安全なフック定義

フックを一度特定のペイロード型で定義することで、複数のワークフローや API ルートで自動的に型安全に再利用できます。

```typescript lineNumbers
import { defineHook } from "workflow";

// Define once with a specific payload type
const approvalHook = defineHook<{ // [!code highlight]
  approved: boolean; // [!code highlight]
  comment: string; // [!code highlight]
}>(); // [!code highlight]

// In your workflow
export async function workflowWithApproval() {
  "use workflow";

  const hook = approvalHook.create();
  const result = await hook; // Fully typed as { approved: boolean; comment: string }

  console.log("Approved:", result.approved);
  console.log("Comment:", result.comment);
}
```

### 型安全な再開

フックは同じ定義済みフックとトークンを使って再開できます。同じフックを使用することで、フックを再開する際にペイロードが定義された型に一致していることを保証できます。

```typescript lineNumbers
// Use the same defined hook to resume
export async function POST(request: Request) {
  const { token, approved, comment } = await request.json();

  // Type-safe resumption - TypeScript ensures the payload matches
  const result = await approvalHook.resume(token, { // [!code highlight]
    approved, // [!code highlight]
    comment, // [!code highlight]
  }); // [!code highlight]

  if (!result) {
    return Response.json({ error: "Hook not found" }, { status: 404 });
  }

  return Response.json({ success: true, runId: result.runId });
}
```

### スキーマによる検証と変換

`schema` オプションを使って、フックペイロードのランタイム検証と変換を提供できます。このオプションは [Standard Schema v1](https://standardschema.dev) 仕様に準拠した任意のバリデータを受け入れます。

<Callout type="info">
Standard Schema はスキーマ検証ライブラリのための標準化された仕様です。Zod、Valibot、ArkType、Effect Schema など、主要な検証ライブラリの多くがこれをサポートしています。カスタムバリデータを作成することも可能です。
</Callout>

#### defineHook での Zod の利用

以下は [Zod](https://zod.dev) を使用してフックペイロードを検証・変換する例です:

```typescript lineNumbers
import { defineHook } from "workflow";
import { z } from "zod";

export const approvalHook = defineHook({
  schema: z.object({ // [!code highlight]
    approved: z.boolean(), // [!code highlight]
    comment: z.string().min(1).transform((value) => value.trim()), // [!code highlight]
  }), // [!code highlight]
});

export async function approvalWorkflow(approvalId: string) {
  "use workflow";

  const hook = approvalHook.create({
    token: `approval:${approvalId}`,
  });

  // Payload is automatically typed based on the schema
  const { approved, comment } = await hook;
  console.log("Approved:", approved);
  console.log("Comment (trimmed):", comment);
}
```

API ルートからフックを再開する際、スキーマはワークフローが再開される前に受信ペイロードを検証して変換します:

```typescript lineNumbers
export async function POST(request: Request) {
  // Incoming payload: { token: "...", approved: true, comment: "   Ready!   " }
  const { token, approved, comment } = await request.json();

  // The schema validates and transforms the payload:
  // - Checks that `approved` is a boolean
  // - Checks that `comment` is a non-empty string
  // - Trims whitespace from the comment
  // If validation fails, an error is thrown and the hook is not resumed
  await approvalHook.resume(token, { // [!code highlight]
    approved, // [!code highlight]
    comment, // Automatically trimmed to "Ready!" // [!code highlight]
  }); // [!code highlight]

  return Response.json({ success: true });
}
```

#### 他の Standard Schema ライブラリの利用

同じパターンは Standard Schema v1 準拠の任意のライブラリで動作します。以下は [Valibot](https://valibot.dev) を使った例です:

```typescript lineNumbers
import { defineHook } from "workflow";
import * as v from "valibot";

export const approvalHook = defineHook({
  schema: v.object({ // [!code highlight]
    approved: v.boolean(), // [!code highlight]
    comment: v.pipe(v.string(), v.minLength(1), v.trim()), // [!code highlight]
  }), // [!code highlight]
});
```

### トークンのカスタマイズ

トークンは特定のフックを識別し、フックを再開するために使用されます。ユースケースに合わせてトークンをより具体的にカスタマイズできます。

```typescript lineNumbers
const slackHook = defineHook<{ text: string; userId: string }>();

export async function slackBotWorkflow(channelId: string) {
  "use workflow";

  const hook = slackHook.create({
    token: `slack:${channelId}`, // [!code highlight]
  });

  const message = await hook;
  console.log(`Message from ${message.userId}: ${message.text}`);
}
```

## 関連関数

* [`createHook()`](/docs/api-reference/workflow/create-hook) - ワークフロー内でフックを作成します。
* [`resumeHook()`](/docs/api-reference/workflow-api/resume-hook) - ペイロードを使ってフックを再開します。
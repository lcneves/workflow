---
title: defineHook
---

Crée un helper de hook typé qui garantit que le type du payload est cohérent entre la création du hook et sa reprise.

Ceci est un wrapper léger autour de [`createHook()`](/docs/api-reference/workflow/create-hook) et [`resumeHook()`](/docs/api-reference/workflow-api/resume-hook) pour éviter les incompatibilités de type. Il prend également en charge la validation et la transformation optionnelles à l'exécution des payloads en utilisant n'importe quel validateur conforme à [Standard Schema v1](https://standardschema.dev) comme Zod ou Valibot.

<Callout>
Nous recommandons d'utiliser `defineHook()` plutôt que `createHook()` dans les codebases de production pour une meilleure sécurité de type et une validation optionnelle à l'exécution.
</Callout>

```ts lineNumbers
import { defineHook } from "workflow";

const nameHook = defineHook<{
  name: string;
}>();

export async function nameWorkflow() {
  "use workflow";

  const hook = nameHook.create();  // [!code highlight]
  const result = await hook; // Fully typed as { name: string }
  console.log("Name:", result.name);
}
```

## Signature de l'API

### Paramètres

<TSDoc
definition={`
import { defineHook } from "workflow";
export default defineHook;`}
showSections={['parameters']}
/>

### Valeur renvoyée

<TSDoc
definition={`
interface DefineHook<T> {
  /**

* Creates a new hook with the defined payload type.
  */
  create: (options?: HookOptions) => Hook<T>;

  /**

* Resumes a hook by sending a payload with the defined type.
   */
  resume: (token: string, payload: T) => Promise<HookEntity | null>;
}
export default DefineHook;`}
/>

## Exemples

### Définition basique d'un hook typé

En définissant le hook une fois avec un type de payload spécifique, vous pouvez le réutiliser dans plusieurs workflows et routes d'API avec une sécurité de type automatique.

```typescript lineNumbers
import { defineHook } from "workflow";

// Define once with a specific payload type
const approvalHook = defineHook<{ // [!code highlight]
  approved: boolean; // [!code highlight]
  comment: string; // [!code highlight]
}>(); // [!code highlight]

// In your workflow
export async function workflowWithApproval() {
  "use workflow";

  const hook = approvalHook.create();
  const result = await hook; // Fully typed as { approved: boolean; comment: string }

  console.log("Approved:", result.approved);
  console.log("Comment:", result.comment);
}
```

### Reprise avec sécurité de type

Les hooks peuvent être repris à l'aide du même hook défini et d'un token. En utilisant le même hook, vous pouvez garantir que le payload correspond au type défini lors de la reprise du hook.

```typescript lineNumbers
// Use the same defined hook to resume
export async function POST(request: Request) {
  const { token, approved, comment } = await request.json();

  // Type-safe resumption - TypeScript ensures the payload matches
  const result = await approvalHook.resume(token, { // [!code highlight]
    approved, // [!code highlight]
    comment, // [!code highlight]
  }); // [!code highlight]

  if (!result) {
    return Response.json({ error: "Hook not found" }, { status: 404 });
  }

  return Response.json({ success: true, runId: result.runId });
}
```

### Valider et transformer avec un schéma

Vous pouvez fournir une validation et une transformation à l'exécution des payloads de hook en utilisant l'option `schema`. Cette option accepte n'importe quel validateur conforme à la spécification [Standard Schema v1](https://standardschema.dev).

<Callout type="info">
Standard Schema est une spécification standardisée pour les bibliothèques de validation de schémas. La plupart des bibliothèques de validation populaires la prennent en charge, y compris Zod, Valibot, ArkType et Effect Schema. Vous pouvez également écrire des validateurs personnalisés.
</Callout>

#### Utiliser Zod avec defineHook

Voici un exemple utilisant [Zod](https://zod.dev) pour valider et transformer les payloads de hook :

```typescript lineNumbers
import { defineHook } from "workflow";
import { z } from "zod";

export const approvalHook = defineHook({
  schema: z.object({ // [!code highlight]
    approved: z.boolean(), // [!code highlight]
    comment: z.string().min(1).transform((value) => value.trim()), // [!code highlight]
  }), // [!code highlight]
});

export async function approvalWorkflow(approvalId: string) {
  "use workflow";

  const hook = approvalHook.create({
    token: `approval:${approvalId}`,
  });

  // Payload is automatically typed based on the schema
  const { approved, comment } = await hook;
  console.log("Approved:", approved);
  console.log("Comment (trimmed):", comment);
}
```

Lors de la reprise du hook depuis une route d'API, le schéma valide et transforme le payload entrant avant que le workflow ne reprenne :

```typescript lineNumbers
export async function POST(request: Request) {
  // Incoming payload: { token: "...", approved: true, comment: "   Ready!   " }
  const { token, approved, comment } = await request.json();

  // The schema validates and transforms the payload:
  // - Checks that `approved` is a boolean
  // - Checks that `comment` is a non-empty string
  // - Trims whitespace from the comment
  // If validation fails, an error is thrown and the hook is not resumed
  await approvalHook.resume(token, { // [!code highlight]
    approved, // [!code highlight]
    comment, // Automatically trimmed to "Ready!" // [!code highlight]
  }); // [!code highlight]

  return Response.json({ success: true });
}
```

#### Utiliser d'autres bibliothèques Standard Schema

Le même modèle fonctionne avec n'importe quelle bibliothèque conforme à Standard Schema v1. Voici un exemple avec [Valibot](https://valibot.dev) :

```typescript lineNumbers
import { defineHook } from "workflow";
import * as v from "valibot";

export const approvalHook = defineHook({
  schema: v.object({ // [!code highlight]
    approved: v.boolean(), // [!code highlight]
    comment: v.pipe(v.string(), v.minLength(1), v.trim()), // [!code highlight]
  }), // [!code highlight]
});
```

### Personnalisation des tokens

Les tokens sont utilisés pour identifier un hook spécifique et pour reprendre un hook. Vous pouvez personnaliser le token pour l'adapter à un cas d'utilisation.

```typescript lineNumbers
const slackHook = defineHook<{ text: string; userId: string }>();

export async function slackBotWorkflow(channelId: string) {
  "use workflow";

  const hook = slackHook.create({
    token: `slack:${channelId}`, // [!code highlight]
  });

  const message = await hook;
  console.log(`Message from ${message.userId}: ${message.text}`);
}
```

## Fonctions associées

* [`createHook()`](/docs/api-reference/workflow/create-hook) - Créer un hook dans un workflow.
* [`resumeHook()`](/docs/api-reference/workflow-api/resume-hook) - Reprendre un hook avec un payload.
---
title: WorkflowChatTransport
---

<Callout type="warn">
O pacote `@workflow/ai` está atualmente em desenvolvimento ativo e deve ser considerado experimental.
</Callout>

Uma implementação de transporte de chat para o AI SDK que fornece streaming de mensagens confiável com reconexão automática em fluxos interrompidos. Este transporte é um substituto direto para o transporte padrão do AI SDK, permitindo recuperação transparente de problemas de rede, atualizações de página ou timeouts de Vercel Function.

<Callout>
`WorkflowChatTransport` implementa a interface [`ChatTransport`](https://ai-sdk.dev/docs/ai-sdk-ui/transport) do AI SDK e foi projetado para funcionar com aplicações de chat baseadas em workflows. Ele requer endpoints que retornem o cabeçalho `x-workflow-run-id` para habilitar a retomada de stream.
</Callout>

```typescript lineNumbers
import { useChat } from "@ai-sdk/react";
import { WorkflowChatTransport } from "@workflow/ai";

export default function Chat() {
  const { messages, sendMessage } = useChat({
    transport: new WorkflowChatTransport(),
  });

  return (
    <div>
      {messages.map((m) => (
        <div key={m.id}>{m.content}</div>
      ))}
    </div>
  );
}
```

## Assinatura da API

### Classe

<TSDoc
definition={`
import { WorkflowChatTransport } from "@workflow/ai";
export default WorkflowChatTransport;`}
/>

### WorkflowChatTransportOptions

<TSDoc
definition={`
import type { WorkflowChatTransportOptions } from "@workflow/ai";
export default WorkflowChatTransportOptions;`}
/>

## Principais Recursos

- **Reconexão Automática**: Recupera automaticamente de streams interrompidos com limites de tentativas configuráveis
- **Integração com Workflows**: Funciona perfeitamente com endpoints baseados em workflows que fornecem o cabeçalho `x-workflow-run-id`
- **Requisições Personalizáveis**: Permite interceptar e modificar requisições via `prepareSendMessagesRequest` e `prepareReconnectToStreamRequest`
- **Callbacks de Stream**: Fornece hooks para rastrear o ciclo de vida do chat via `onChatSendMessage` e `onChatEnd`
- **Fetch Personalizado**: Suporta implementações personalizadas de fetch para casos de uso avançados

## Informações importantes

- O transporte espera que os endpoints de chat retornem o cabeçalho `x-workflow-run-id` na resposta para habilitar a retomada do stream
- Por padrão, o transporte faz POST para `/api/chat` e reconecta via `/api/chat/{runId}/stream`
- O callback `onChatSendMessage` recebe o objeto de resposta completo, permitindo que você extraia e armazene o ID de execução do workflow para retomada de sessão
- Interrupções de stream são detectadas automaticamente quando um chunk de "finish" não é recebido na resposta inicial
- A opção `maxConsecutiveErrors` controla quantas tentativas de reconexão são feitas antes de desistir (padrão: 3)

## Exemplos

### Configuração Básica do Chat

```typescript
"use client";

import { useChat } from "@ai-sdk/react";
import { WorkflowChatTransport } from "@workflow/ai";
import { useState } from "react";

export default function BasicChat() {
  const [input, setInput] = useState("");
  const { messages, sendMessage } = useChat({
    transport: new WorkflowChatTransport(),
  });

  return (
    <div>
      <div className="space-y-4">
        {messages.map((m) => (
          <div key={m.id}>
            <strong>{m.role}:</strong> {m.content}
          </div>
        ))}
      </div>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          sendMessage({ text: input });
          setInput("");
        }}
      >
        <input
          value={input}
          placeholder="Say something..."
          onChange={(e) => setInput(e.currentTarget.value)}
        />
      </form>
    </div>
  );
}
```

### Com Persistência de Sessão e Retomada

```typescript
"use client";

import { useChat } from "@ai-sdk/react";
import { WorkflowChatTransport } from "@workflow/ai";
import { useMemo, useState } from "react";

export default function ChatWithResumption() {
  const [input, setInput] = useState("");
  const activeWorkflowRunId = useMemo(() => {
    if (typeof window === "undefined") return;
    return localStorage.getItem("active-workflow-run-id") ?? undefined;
  }, []);

  const { messages, sendMessage } = useChat({
    resume: !!activeWorkflowRunId,
    transport: new WorkflowChatTransport({
      onChatSendMessage: (response, options) => {
        // Save chat history to localStorage
        localStorage.setItem(
          "chat-history",
          JSON.stringify(options.messages)
        );

        // Extract and store the workflow run ID for session resumption
        const workflowRunId = response.headers.get("x-workflow-run-id");
        if (workflowRunId) {
          localStorage.setItem("active-workflow-run-id", workflowRunId);
        }
      },
      onChatEnd: ({ chatId, chunkIndex }) => {
        console.log(`Chat ${chatId} completed with ${chunkIndex} chunks`);
        // Clear the active run ID when chat completes
        localStorage.removeItem("active-workflow-run-id");
      },
    }),
  });

  return (
    <div>
      <div className="space-y-4">
        {messages.map((m) => (
          <div key={m.id}>
            <strong>{m.role}:</strong> {m.content}
          </div>
        ))}
      </div>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          sendMessage({ text: input });
          setInput("");
        }}
      >
        <input
          value={input}
          placeholder="Say something..."
          onChange={(e) => setInput(e.currentTarget.value)}
        />
      </form>
    </div>
  );
}
```

### Com Configuração Personalizada de Requisições

```typescript
"use client";

import { useChat } from "@ai-sdk/react";
import { WorkflowChatTransport } from "@workflow/ai";
import { useState } from "react";

export default function ChatWithCustomConfig() {
  const [input, setInput] = useState("");
  const { messages, sendMessage } = useChat({
    transport: new WorkflowChatTransport({
      prepareSendMessagesRequest: async (config) => {
        return {
          ...config,
          api: "/api/chat",
          headers: {
            ...config.headers,
            "Authorization": `Bearer ${process.env.NEXT_PUBLIC_API_TOKEN}`,
            "X-Custom-Header": "custom-value",
          },
          credentials: "include",
        };
      },
      prepareReconnectToStreamRequest: async (config) => {
        return {
          ...config,
          headers: {
            ...config.headers,
            "Authorization": `Bearer ${process.env.NEXT_PUBLIC_API_TOKEN}`,
          },
          credentials: "include",
        };
      },
      maxConsecutiveErrors: 5,
    }),
  });

  return (
    <div>
      <div className="space-y-4">
        {messages.map((m) => (
          <div key={m.id}>
            <strong>{m.role}:</strong> {m.content}
          </div>
        ))}
      </div>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          sendMessage({ text: input });
          setInput("");
        }}
      >
        <input
          value={input}
          placeholder="Say something..."
          onChange={(e) => setInput(e.currentTarget.value)}
        />
      </form>
    </div>
  );
}
```

## Veja também

- [DurableAgent](/docs/api-reference/workflow-ai/durable-agent) - Construindo agentes de IA duráveis dentro de workflows
- [Documentação do AI SDK `useChat`](https://ai-sdk.dev/docs/reference/ai-sdk-ui/use-chat) - Usando `useChat` com transports personalizados
- [Workflows e Etapas](/docs/foundations/workflows-and-steps) - Entendendo os fundamentos de workflows
- [Exemplo "flight-booking-app"](https://github.com/vercel/workflow-examples/tree/main/flight-booking-app) - Uma aplicação de exemplo que utiliza `WorkflowChatTransport`
{"version":3,"sources":["../../src/workflows/6_batching.ts"],"sourcesContent":["import chunk from 'lodash.chunk';\n\nconst ARRAY_LENGTH = 250;\nconst CHUNK_SIZE = 50;\n\n/**\n * Pattern 1: Each item in a batch gets processed in a step function\n *\n * If a step fails, doesn't fail the entire batch.\n */\nexport async function batchOverSteps() {\n  'use workflow';\n\n  console.log('Workflow started');\n  const arr = Array.from({ length: ARRAY_LENGTH }, (_, i) => i + 1);\n  const chunkSize = CHUNK_SIZE;\n  console.log(\n    `Chunking array with size: ${arr.length} and chunk size: ${chunkSize}`\n  );\n  const chunks = chunk(arr, chunkSize); // Create the batches\n  console.log(\n    `Created ${chunks.length} chunks (${chunks[0].length} items each)`\n  );\n\n  console.log('Starting batch processing');\n  for (const [index, batch] of chunks.entries()) {\n    console.log(`Batch ${index + 1}/${chunks.length}`);\n    await Promise.all(batch.map(logItem));\n  }\n  console.log('Batch processing completed');\n  console.log('Workflow completed');\n}\n\nasync function logItem(item: number) {\n  'use step';\n  console.log(item, Date.now());\n}\n\n/**\n * Pattern 2: Each batch gets processed in a step function\n *\n * NOTE: If a batch fails, the entire batch will be retried from the beginning.\n */\nexport async function batchInStep() {\n  'use workflow';\n\n  console.log('Workflow started');\n  const arr = Array.from({ length: ARRAY_LENGTH }, (_, i) => i + 1);\n  const chunkSize = CHUNK_SIZE;\n  console.log(\n    `Chunking array with size: ${arr.length} and chunk size: ${chunkSize}`\n  );\n  const chunks = chunk(arr, chunkSize); // Create the batches\n  console.log(\n    `Created ${chunks.length} chunks (${chunks[0].length} items each)`\n  );\n\n  console.log('Starting batch processing');\n  for (const [index, batch] of chunks.entries()) {\n    console.log(`Batch ${index + 1}/${chunks.length}`);\n    await processItems(batch);\n  }\n  console.log('Batch processing completed');\n  console.log('Workflow completed');\n}\n\n/**\n * Step function that processes a batch of items with internal parallelism.\n * Called once per batch, with all items processed in parallel inside the step.\n */\nasync function processItems(items: number[]) {\n  'use step';\n  await Promise.all(\n    items.map(async (item) => {\n      console.log(item, Date.now());\n    })\n  );\n}\n"],"names":["batchInStep","batchOverSteps","logItem","item","console","log","Date","now","processItems","items","Promise","all","map"],"mappings":";;;;;;;;;;;;IA2CsBA,WAAW;eAAXA;;IAjCAC,cAAc;eAAdA;;;AAAf,eAAeA;;AAqBtB;;AAEA,eAAeC,QAAQC,IAAY;IAEjCC,QAAQC,GAAG,CAACF,MAAMG,KAAKC,GAAG;AAC5B;AAOO,eAAeP;;AAqBtB;;AAEA;;;CAGC,GACD,eAAeQ,aAAaC,KAAe;IAEzC,MAAMC,QAAQC,GAAG,CACfF,MAAMG,GAAG,CAAC,OAAOT;QACfC,QAAQC,GAAG,CAACF,MAAMG,KAAKC,GAAG;IAC5B;AAEJ"}
{"version":3,"sources":["../../src/workflows/99_e2e.ts"],"sourcesContent":["import {\n  createHook,\n  createWebhook,\n  FatalError,\n  fetch,\n  getStepMetadata,\n  getWorkflowMetadata,\n  getWritable,\n  type RequestWithResponse,\n  RetryableError,\n  sleep,\n} from 'workflow';\nimport { getRun, start } from 'workflow/api';\nimport { callThrower } from './helpers.js';\n\n//////////////////////////////////////////////////////////\n\nexport async function add(a: number, b: number) {\n  'use step';\n  return a + b;\n}\n\nexport async function addTenWorkflow(input: number) {\n  'use workflow';\n  const a = await add(input, 2);\n  const b = await add(a, 3);\n  const c = await add(b, 5);\n  return c;\n}\n\n//////////////////////////////////////////////////////////\n\n// Helper functions to test nested stack traces\nfunction deepFunction() {\n  throw new Error('Error from deeply nested function');\n}\n\nfunction middleFunction() {\n  deepFunction();\n}\n\nfunction topLevelHelper() {\n  middleFunction();\n}\n\nexport async function nestedErrorWorkflow() {\n  'use workflow';\n  topLevelHelper();\n  return 'never reached';\n}\n\n//////////////////////////////////////////////////////////\n\nasync function randomDelay(v: string) {\n  'use step';\n  await new Promise((resolve) => setTimeout(resolve, Math.random() * 3000));\n  return v.toUpperCase();\n}\n\nexport async function promiseAllWorkflow() {\n  'use workflow';\n  const [a, b, c] = await Promise.all([\n    randomDelay('a'),\n    randomDelay('b'),\n    randomDelay('c'),\n  ]);\n  return a + b + c;\n}\n\n//////////////////////////////////////////////////////////\n\nasync function specificDelay(delay: number, v: string) {\n  'use step';\n  await new Promise((resolve) => setTimeout(resolve, delay));\n  return v.toUpperCase();\n}\n\nexport async function promiseRaceWorkflow() {\n  'use workflow';\n  const winner = await Promise.race([\n    specificDelay(10000, 'a'),\n    specificDelay(100, 'b'), // \"b\" should always win\n    specificDelay(20000, 'c'),\n  ]);\n  return winner;\n}\n\n//////////////////////////////////////////////////////////\n\nasync function stepThatFails() {\n  'use step';\n  throw new FatalError('step failed');\n}\n\nexport async function promiseAnyWorkflow() {\n  'use workflow';\n  const winner = await Promise.any([\n    stepThatFails(),\n    specificDelay(1000, 'b'), // \"b\" should always win\n    specificDelay(3000, 'c'),\n  ]);\n  return winner;\n}\n\n//////////////////////////////////////////////////////////\n\n// Name should not conflict with genStream in 3_streams.ts\n// TODO: swc transform should mangle names to avoid conflicts\nasync function genReadableStream() {\n  'use step';\n  const encoder = new TextEncoder();\n  return new ReadableStream({\n    async start(controller) {\n      for (let i = 0; i < 10; i++) {\n        console.log('enqueueing', i);\n        controller.enqueue(encoder.encode(`${i}\\n`));\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n      console.log('closing controller');\n      controller.close();\n    },\n  });\n}\n\nexport async function readableStreamWorkflow() {\n  'use workflow';\n  console.log('calling genReadableStream');\n  const stream = await genReadableStream();\n  console.log('genReadableStream returned', stream);\n  return stream;\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function hookWorkflow(token: string, customData: string) {\n  'use workflow';\n\n  type Payload = { message: string; customData: string; done?: boolean };\n\n  const hook = createHook<Payload>({\n    token,\n    metadata: { customData },\n  });\n\n  const payloads: Payload[] = [];\n  for await (const payload of hook) {\n    payloads.push(payload);\n\n    if (payload.done) {\n      break;\n    }\n  }\n\n  return payloads;\n}\n\n//////////////////////////////////////////////////////////\n\nasync function sendWebhookResponse(req: RequestWithResponse) {\n  'use step';\n  const body = await req.text();\n  await req.respondWith(new Response('Hello from webhook!'));\n  return body;\n}\n\nexport async function webhookWorkflow(\n  token: string,\n  token2: string,\n  token3: string\n) {\n  'use workflow';\n\n  type Payload = { url: string; method: string; body: string };\n  const payloads: Payload[] = [];\n\n  const webhookWithDefaultResponse = createWebhook({ token });\n\n  const res = new Response('Hello from static response!', { status: 402 });\n  console.log('res', res);\n  const webhookWithStaticResponse = createWebhook({\n    token: token2,\n    respondWith: res,\n  });\n  const webhookWithManualResponse = createWebhook({\n    token: token3,\n    respondWith: 'manual',\n  });\n\n  // Webhook with default response\n  {\n    const req = await webhookWithDefaultResponse;\n    const body = await req.text();\n    payloads.push({ url: req.url, method: req.method, body });\n  }\n\n  // Webhook with static response\n  {\n    const req = await webhookWithStaticResponse;\n    const body = await req.text();\n    payloads.push({ url: req.url, method: req.method, body });\n  }\n\n  // Webhook with manual response\n  {\n    const req = await webhookWithManualResponse;\n    const body = await sendWebhookResponse(req);\n    payloads.push({ url: req.url, method: req.method, body });\n  }\n\n  return payloads;\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function sleepingWorkflow() {\n  'use workflow';\n  const startTime = Date.now();\n  await sleep('10s');\n  const endTime = Date.now();\n  return { startTime, endTime };\n}\n\n//////////////////////////////////////////////////////////\n\nasync function nullByteStep() {\n  'use step';\n  return 'null byte \\0';\n}\n\nexport async function nullByteWorkflow() {\n  'use workflow';\n  const a = await nullByteStep();\n  return a;\n}\n\n//////////////////////////////////////////////////////////\n\nasync function stepWithMetadata() {\n  'use step';\n  const stepMetadata = getStepMetadata();\n  const workflowMetadata = getWorkflowMetadata();\n  return { stepMetadata, workflowMetadata };\n}\n\nexport async function workflowAndStepMetadataWorkflow() {\n  'use workflow';\n  const workflowMetadata = getWorkflowMetadata();\n  const { stepMetadata, workflowMetadata: innerWorkflowMetadata } =\n    await stepWithMetadata();\n  return {\n    workflowMetadata: {\n      workflowRunId: workflowMetadata.workflowRunId,\n      workflowStartedAt: workflowMetadata.workflowStartedAt,\n      url: workflowMetadata.url,\n    },\n    stepMetadata,\n    innerWorkflowMetadata,\n  };\n}\n\n//////////////////////////////////////////////////////////\n\nasync function stepWithOutputStreamBinary(\n  writable: WritableStream,\n  text: string\n) {\n  'use step';\n  const writer = writable.getWriter();\n  // binary data\n  await writer.write(new TextEncoder().encode(text));\n  writer.releaseLock();\n}\n\nasync function stepWithOutputStreamObject(writable: WritableStream, obj: any) {\n  'use step';\n  const writer = writable.getWriter();\n  // object data\n  await writer.write(obj);\n  writer.releaseLock();\n}\n\nasync function stepCloseOutputStream(writable: WritableStream) {\n  'use step';\n  await writable.close();\n}\n\nexport async function outputStreamWorkflow() {\n  'use workflow';\n  const writable = getWritable();\n  const namedWritable = getWritable({ namespace: 'test' });\n  await sleep('1s');\n  await stepWithOutputStreamBinary(writable, 'Hello, world!');\n  await sleep('1s');\n  await stepWithOutputStreamBinary(namedWritable, 'Hello, named stream!');\n  await sleep('1s');\n  await stepWithOutputStreamObject(writable, { foo: 'test' });\n  await sleep('1s');\n  await stepWithOutputStreamObject(namedWritable, { foo: 'bar' });\n  await sleep('1s');\n  await stepCloseOutputStream(writable);\n  await stepCloseOutputStream(namedWritable);\n  return 'done';\n}\n\n//////////////////////////////////////////////////////////\n\nasync function stepWithOutputStreamInsideStep(text: string) {\n  'use step';\n  // Call getWritable directly inside the step function\n  const writable = getWritable();\n  const writer = writable.getWriter();\n  await writer.write(new TextEncoder().encode(text));\n  writer.releaseLock();\n}\n\nasync function stepWithNamedOutputStreamInsideStep(\n  namespace: string,\n  obj: any\n) {\n  'use step';\n  // Call getWritable with namespace directly inside the step function\n  const writable = getWritable({ namespace });\n  const writer = writable.getWriter();\n  await writer.write(obj);\n  writer.releaseLock();\n}\n\nasync function stepCloseOutputStreamInsideStep(namespace?: string) {\n  'use step';\n  // Call getWritable directly inside the step function and close it\n  const writable = getWritable({ namespace });\n  await writable.close();\n}\n\nexport async function outputStreamInsideStepWorkflow() {\n  'use workflow';\n  await sleep('1s');\n  await stepWithOutputStreamInsideStep('Hello from step!');\n  await sleep('1s');\n  await stepWithNamedOutputStreamInsideStep('step-ns', {\n    message: 'Hello from named stream in step!',\n  });\n  await sleep('1s');\n  await stepWithOutputStreamInsideStep('Second message');\n  await sleep('1s');\n  await stepWithNamedOutputStreamInsideStep('step-ns', { counter: 42 });\n  await sleep('1s');\n  await stepCloseOutputStreamInsideStep();\n  await stepCloseOutputStreamInsideStep('step-ns');\n  return 'done';\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function fetchWorkflow() {\n  'use workflow';\n  const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');\n  const data = await response.json();\n  return data;\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function promiseRaceStressTestDelayStep(\n  dur: number,\n  resp: number\n): Promise<number> {\n  'use step';\n\n  console.log(`sleep`, resp, `/`, dur);\n  await new Promise((resolve) => setTimeout(resolve, dur));\n\n  console.log(resp, `done`);\n  return resp;\n}\n\nexport async function promiseRaceStressTestWorkflow() {\n  'use workflow';\n\n  const promises = new Map<number, Promise<number>>();\n  const done: number[] = [];\n  for (let i = 0; i < 5; i++) {\n    const resp = i;\n    const dur = 1000 * 5 * i; // 5 seconds apart\n    console.log(`sched`, resp, `/`, dur);\n    promises.set(i, promiseRaceStressTestDelayStep(dur, resp));\n  }\n\n  while (promises.size > 0) {\n    console.log(`promises.size`, promises.size);\n    const res = await Promise.race(promises.values());\n    console.log(res);\n    done.push(res);\n    promises.delete(res);\n  }\n\n  return done;\n}\n\n//////////////////////////////////////////////////////////\n\nasync function stepThatRetriesAndSucceeds() {\n  'use step';\n  const { attempt } = getStepMetadata();\n  console.log(`stepThatRetriesAndSucceeds - attempt: ${attempt}`);\n\n  // Fail on attempts 1 and 2, succeed on attempt 3\n  if (attempt < 3) {\n    console.log(`Attempt ${attempt} - throwing error to trigger retry`);\n    throw new Error(`Failed on attempt ${attempt}`);\n  }\n\n  console.log(`Attempt ${attempt} - succeeding`);\n  return attempt;\n}\n\nexport async function retryAttemptCounterWorkflow() {\n  'use workflow';\n  console.log('Starting retry attempt counter workflow');\n\n  // This step should fail twice and succeed on the third attempt\n  const finalAttempt = await stepThatRetriesAndSucceeds();\n\n  console.log(`Workflow completed with final attempt: ${finalAttempt}`);\n  return { finalAttempt };\n}\n\n//////////////////////////////////////////////////////////\n\nasync function stepThatThrowsRetryableError() {\n  'use step';\n  const { attempt, stepStartedAt } = getStepMetadata();\n  if (attempt === 1) {\n    throw new RetryableError('Retryable error', {\n      retryAfter: '10s',\n    });\n  }\n  return {\n    attempt,\n    stepStartedAt,\n    duration: Date.now() - stepStartedAt.getTime(),\n  };\n}\n\nexport async function crossFileErrorWorkflow() {\n  'use workflow';\n  // This will throw an error from the imported helpers.ts file\n  callThrower();\n  return 'never reached';\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function retryableAndFatalErrorWorkflow() {\n  'use workflow';\n\n  const retryableResult = await stepThatThrowsRetryableError();\n\n  let gotFatalError = false;\n  try {\n    await stepThatFails();\n  } catch (error: any) {\n    if (FatalError.is(error)) {\n      gotFatalError = true;\n    }\n  }\n\n  return { retryableResult, gotFatalError };\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function hookCleanupTestWorkflow(\n  token: string,\n  customData: string\n) {\n  'use workflow';\n\n  type Payload = { message: string; customData: string };\n\n  const hook = createHook<Payload>({\n    token,\n    metadata: { customData },\n  });\n\n  // Wait for exactly one payload\n  const payload = await hook;\n\n  return {\n    message: payload.message,\n    customData: payload.customData,\n    hookCleanupTestData: 'workflow_completed',\n  };\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function stepFunctionPassingWorkflow() {\n  'use workflow';\n  // Pass a step function reference to another step (without closure vars)\n  const result = await stepWithStepFunctionArg(doubleNumber);\n  return result;\n}\n\nasync function stepWithStepFunctionArg(stepFn: (x: number) => Promise<number>) {\n  'use step';\n  // Call the passed step function reference\n  const result = await stepFn(10);\n  return result * 2;\n}\n\nasync function doubleNumber(x: number) {\n  'use step';\n  return x * 2;\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function stepFunctionWithClosureWorkflow() {\n  'use workflow';\n  const multiplier = 3;\n  const prefix = 'Result: ';\n\n  // Create a step function that captures closure variables\n  const calculate = async (x: number) => {\n    'use step';\n    return `${prefix}${x * multiplier}`;\n  };\n\n  // Pass the step function (with closure vars) to another step\n  const result = await stepThatCallsStepFn(calculate, 7);\n  return result;\n}\n\nasync function stepThatCallsStepFn(\n  stepFn: (x: number) => Promise<string>,\n  value: number\n) {\n  'use step';\n  // Call the passed step function - closure vars should be preserved\n  const result = await stepFn(value);\n  return `Wrapped: ${result}`;\n}\n\n//////////////////////////////////////////////////////////\n\nexport async function closureVariableWorkflow(baseValue: number) {\n  'use workflow';\n  // biome-ignore lint/style/useConst: Intentionally using `let` instead of `const`\n  let multiplier = 3;\n  const prefix = 'Result: ';\n\n  // Nested step function that uses closure variables\n  const calculate = async () => {\n    'use step';\n    const result = baseValue * multiplier;\n    return `${prefix}${result}`;\n  };\n\n  const output = await calculate();\n  return output;\n}\n\n//////////////////////////////////////////////////////////\n\n// Child workflow that will be spawned from another workflow\nexport async function childWorkflow(value: number) {\n  'use workflow';\n  // Do some processing\n  const doubled = await doubleValue(value);\n  return { childResult: doubled, originalValue: value };\n}\n\nasync function doubleValue(value: number) {\n  'use step';\n  return value * 2;\n}\n\n// Step function that spawns another workflow using start()\nasync function spawnChildWorkflow(value: number) {\n  'use step';\n  // start() can only be called inside a step function, not directly in workflow code\n  const childRun = await start(childWorkflow, [value]);\n  return childRun.runId;\n}\n\n// Step function that waits for a workflow run to complete and returns its result\nasync function awaitWorkflowResult<T>(runId: string) {\n  'use step';\n  const run = getRun<T>(runId);\n  const result = await run.returnValue;\n  return result;\n}\n\nexport async function spawnWorkflowFromStepWorkflow(inputValue: number) {\n  'use workflow';\n  // Spawn the child workflow from inside a step function\n  const childRunId = await spawnChildWorkflow(inputValue);\n\n  // Wait for the child workflow to complete (also in a step)\n  const childResult = await awaitWorkflowResult<{\n    childResult: number;\n    originalValue: number;\n  }>(childRunId);\n\n  return {\n    parentInput: inputValue,\n    childRunId,\n    childResult,\n  };\n}\n"],"names":["add","addTenWorkflow","childWorkflow","closureVariableWorkflow","crossFileErrorWorkflow","fetchWorkflow","hookCleanupTestWorkflow","hookWorkflow","nestedErrorWorkflow","nullByteWorkflow","outputStreamInsideStepWorkflow","outputStreamWorkflow","promiseAllWorkflow","promiseAnyWorkflow","promiseRaceStressTestDelayStep","promiseRaceStressTestWorkflow","promiseRaceWorkflow","readableStreamWorkflow","retryAttemptCounterWorkflow","retryableAndFatalErrorWorkflow","sleepingWorkflow","spawnWorkflowFromStepWorkflow","stepFunctionPassingWorkflow","stepFunctionWithClosureWorkflow","webhookWorkflow","workflowAndStepMetadataWorkflow","a","b","input","randomDelay","v","Promise","resolve","setTimeout","Math","random","toUpperCase","specificDelay","delay","stepThatFails","FatalError","genReadableStream","encoder","TextEncoder","ReadableStream","start","controller","i","console","log","enqueue","encode","close","token","customData","sendWebhookResponse","req","body","text","respondWith","Response","token2","token3","nullByteStep","stepWithMetadata","stepMetadata","getStepMetadata","workflowMetadata","getWorkflowMetadata","stepWithOutputStreamBinary","writable","writer","getWriter","write","releaseLock","stepWithOutputStreamObject","obj","stepCloseOutputStream","stepWithOutputStreamInsideStep","getWritable","stepWithNamedOutputStreamInsideStep","namespace","stepCloseOutputStreamInsideStep","dur","resp","stepThatRetriesAndSucceeds","attempt","Error","stepThatThrowsRetryableError","stepStartedAt","RetryableError","retryAfter","duration","Date","now","getTime","stepWithStepFunctionArg","stepFn","result","doubleNumber","x","stepThatCallsStepFn","value","baseValue","doubleValue","spawnChildWorkflow","childRun","runId","awaitWorkflowResult","run","getRun","returnValue","inputValue"],"mappings":"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"}
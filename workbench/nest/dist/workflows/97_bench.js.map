{"version":3,"sources":["../../src/workflows/97_bench.ts"],"sourcesContent":["// Benchmark workflows for performance testing\n\nasync function doWork() {\n  'use step';\n  return 42;\n}\n\n// Workflow with no steps - pure orchestration\nexport async function noStepsWorkflow(input: number) {\n  'use workflow';\n  return input * 2;\n}\n\n// Workflow with 1 step\nexport async function oneStepWorkflow(input: number) {\n  'use workflow';\n  const result = await doWork();\n  return result + input;\n}\n\n// Workflow with 10 sequential steps\nexport async function tenSequentialStepsWorkflow() {\n  'use workflow';\n  let result = 0;\n  for (let i = 0; i < 10; i++) {\n    result = await doWork();\n  }\n  return result;\n}\n\n// Workflow with 10 parallel steps\nexport async function tenParallelStepsWorkflow() {\n  'use workflow';\n  const promises = [];\n  for (let i = 0; i < 10; i++) {\n    promises.push(doWork());\n  }\n  const results = await Promise.all(promises);\n  return results.reduce((sum, val) => sum + val, 0);\n}\n\n// Step that generates a stream with 10 chunks\nasync function genBenchStream(): Promise<ReadableStream<Uint8Array>> {\n  'use step';\n  const encoder = new TextEncoder();\n  return new ReadableStream<Uint8Array>({\n    async start(controller) {\n      for (let i = 0; i < 10; i++) {\n        controller.enqueue(encoder.encode(`${i}\\n`));\n        // Small delay to avoid synchronous close issues on local world\n        await new Promise((resolve) => setTimeout(resolve, 10));\n      }\n      controller.close();\n    },\n  });\n}\n\n// Step that transforms a stream by doubling each number\nasync function doubleNumbers(\n  stream: ReadableStream<Uint8Array>\n): Promise<ReadableStream<Uint8Array>> {\n  'use step';\n  const decoder = new TextDecoder();\n  const encoder = new TextEncoder();\n\n  const transformStream = new TransformStream<Uint8Array, Uint8Array>({\n    transform(chunk, controller) {\n      const text = decoder.decode(chunk, { stream: true });\n      const lines = text.split('\\n');\n      for (const line of lines) {\n        if (line.trim()) {\n          const num = parseInt(line, 10);\n          controller.enqueue(encoder.encode(`${num * 2}\\n`));\n        }\n      }\n    },\n  });\n\n  return stream.pipeThrough(transformStream);\n}\n\n// Workflow that generates and transforms a stream\nexport async function streamWorkflow() {\n  'use workflow';\n  const stream = await genBenchStream();\n  const doubled = await doubleNumbers(stream);\n  return doubled;\n}\n"],"names":["noStepsWorkflow","oneStepWorkflow","streamWorkflow","tenParallelStepsWorkflow","tenSequentialStepsWorkflow","doWork","input","genBenchStream","encoder","TextEncoder","ReadableStream","start","controller","i","enqueue","encode","Promise","resolve","setTimeout","close","doubleNumbers","stream","decoder","TextDecoder","transformStream","TransformStream","transform","chunk","text","decode","lines","split","line","trim","num","parseInt","pipeThrough"],"mappings":"AAAA,8CAA8C;;;;;;;;;;;;;IAQxBA,eAAe;eAAfA;;IAMAC,eAAe;eAAfA;;IAoEAC,cAAc;eAAdA;;IAnDAC,wBAAwB;eAAxBA;;IAVAC,0BAA0B;eAA1BA;;;AAnBtB,eAAeC;IAEb,OAAO;AACT;AAGO,eAAeL,gBAAgBM,KAAa;;AAGnD;;AAGO,eAAeL,gBAAgBK,KAAa;;AAInD;;AAGO,eAAeF;;AAOtB;;AAGO,eAAeD;;AAQtB;;AAEA,8CAA8C;AAC9C,eAAeI;IAEb,MAAMC,UAAU,IAAIC;IACpB,OAAO,IAAIC,eAA2B;QACpC,MAAMC,OAAMC,UAAU;YACpB,IAAK,IAAIC,IAAI,GAAGA,IAAI,IAAIA,IAAK;gBAC3BD,WAAWE,OAAO,CAACN,QAAQO,MAAM,CAAC,GAAGF,EAAE,EAAE,CAAC;gBAC1C,+DAA+D;gBAC/D,MAAM,IAAIG,QAAQ,CAACC,UAAYC,WAAWD,SAAS;YACrD;YACAL,WAAWO,KAAK;QAClB;IACF;AACF;AAEA,wDAAwD;AACxD,eAAeC,cACbC,MAAkC;IAGlC,MAAMC,UAAU,IAAIC;IACpB,MAAMf,UAAU,IAAIC;IAEpB,MAAMe,kBAAkB,IAAIC,gBAAwC;QAClEC,WAAUC,KAAK,EAAEf,UAAU;YACzB,MAAMgB,OAAON,QAAQO,MAAM,CAACF,OAAO;gBAAEN,QAAQ;YAAK;YAClD,MAAMS,QAAQF,KAAKG,KAAK,CAAC;YACzB,KAAK,MAAMC,QAAQF,MAAO;gBACxB,IAAIE,KAAKC,IAAI,IAAI;oBACf,MAAMC,MAAMC,SAASH,MAAM;oBAC3BpB,WAAWE,OAAO,CAACN,QAAQO,MAAM,CAAC,GAAGmB,MAAM,EAAE,EAAE,CAAC;gBAClD;YACF;QACF;IACF;IAEA,OAAOb,OAAOe,WAAW,CAACZ;AAC5B;AAGO,eAAetB;;AAKtB"}